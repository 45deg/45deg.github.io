<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta name="generator" content="Madoko, version 0.9.18-beta" />
  <meta name="viewport" content="initial-scale=1.0" />
  <meta name="author" content="ざくろ" />
  <title>Dynamorphism 概論</title>
  <link rel="stylesheet" type="text/css" href="madoko.css"  class="link">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$']]},
       TeX: { 
         Macros: { mathid: ['\\mathit{#1\\hspace{0.1ex}}',1], mathkw: ['\\mathsf{#1}',1],
                   mdMathspace: ['\\hspace{#1pt}\\hspace{#1pt}\\hspace{#1pt}',1], mdMathindent: ['\\hspace{#1ex}',1], mdMathbr: ['\\\\'],
                 },
  
       }
    });
    MathJax.Hub.Register.StartupHook('TeX AMSmath Ready',function () { 
      MathJax.InputJax.TeX.Definitions.environment['mdMathprearray'] = ['AMSarray',null,null,null,'l','0em','0em'];
    });
  </script>
  <script type="text/javascript" class="preview"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  
  </head>
<body class="madoko">

<div class="body madoko" style="line-adjust:0">

<div class="titleblock align-center para-block" data-line="6" style="text-align:center;line-adjust:0">
<div class="titleheader align-center" data-line="6" style="text-align:center;line-adjust:0">
<div class="title para-block" data-line="6" style="font-size:xx-large;font-weight:bold;margin-bottom:0.5ex;line-adjust:0"><span data-line="6"></span>Dynamorphism 概論</div></div>
<div class="authors align-center" data-line="11" style="text-align:center;width:80%;line-adjust:0"><table class="authorrow columns block"  data-line="11" style="margin-top:2ex;width:100%;line-adjust:0">
<tbody><tr><td class="author column"  data-line="11" style="text-align:center;line-adjust:0">
<div class="authorname" data-line="11" style="font-size:large;line-adjust:0"><span data-line="11"></span>ざくろ</div></td></tr></tbody></table></div></div><span data-line="7"></span>
<nav class="toc toc-contents" ><h2 id="sec-contents" class="clearnum h1 heading-contents"     style="display:block;level:1">Contents</h2>
<div class="tocblock tocblock1" >
<div class="tocitem tocitem1"   ><a href="#hajimeni" class="localref"><span class="heading-label">1</span>.&#8194;はじめに</a></div>
<div class="tocblock tocblock2" >
<div class="tocitem tocitem2"   ><a href="#maegaki" class="localref"><span class="heading-label">1.1</span>.&#8194;まえがき</a></div>
<div class="tocitem tocitem2"   ><a href="#kigou-ya-yougo" class="localref"><span class="heading-label">1.2</span>.&#8194;記号や用語などの説明</a></div></div>
<div class="tocitem tocitem1"   ><a href="#functor-and-fixp" class="localref"><span class="heading-label">2</span>.&#8194;関手と不動点</a></div>
<div class="tocblock tocblock2" >
<div class="tocitem tocitem2"   ><a href="#functor" class="localref"><span class="heading-label">2.1</span>.&#8194;関手</a></div>
<div class="tocitem tocitem2"   ><a href="#fixp" class="localref"><span class="heading-label">2.2</span>.&#8194;不動点</a></div></div>
<div class="tocitem tocitem1"   ><a href="#sec-catamorphism-anamorphism" class="localref"><span class="heading-label">3</span>.&#8194;catamorphism と anamorphism</a></div>
<div class="tocblock tocblock2" >
<div class="tocitem tocitem2"   ><a href="#sec-catamorphism" class="localref"><span class="heading-label">3.1</span>.&#8194;代数とcatamorphism</a></div>
<div class="tocitem tocitem2"   ><a href="#sec-anamorphism" class="localref"><span class="heading-label">3.2</span>.&#8194;余代数とanamorphism</a></div></div>
<div class="tocitem tocitem1"   ><a href="#sec-hylomorphism" class="localref"><span class="heading-label">4</span>.&#8194;hylomorphism</a></div>
<div class="tocitem tocitem1"   ><a href="#sec-histomorphism" class="localref"><span class="heading-label">5</span>.&#8194;histomorphism</a></div>
<div class="tocblock tocblock2" >
<div class="tocitem tocitem2"   ><a href="#sec-ftimes_a-tildef" class="localref"><span class="heading-label">5.1</span>.&#8194;<span class="math-inline">$F^{\times}_A$</span> と <span class="math-inline">$\tilde{F}$</span></a></div>
<div class="tocitem tocitem2"   ><a href="#sec-histomorphism" class="localref"><span class="heading-label">5.2</span>.&#8194;histomorphism</a></div></div>
<div class="tocitem tocitem1"   ><a href="#sec-dynamorphism" class="localref"><span class="heading-label">6</span>.&#8194;dynamorphism</a></div>
<div class="tocitem tocitem1"   ><a href="#matome" class="localref"><span class="heading-label">7</span>.&#8194;まとめ</a></div>
<div class="tocitem tocitem1"   ><a href="#atogaki" class="localref"><span class="heading-label">8</span>.&#8194;あとがき</a></div>
<div class="tocitem tocitem1"   ><a href="#bib" class="localref"><span class="heading-label">9</span>.&#8194;参考文献</a></div></div></nav><h2 id="hajimeni" class="h1"    data-line="9"  style="display:block;bookmark:1.&#8194;\306F \3058 \3081 \306B ;level:1"><span data-line="9"></span><span class="heading-before"><span class="heading-label">1</span>.&#8194;</span><span data-line="9"></span>はじめに</h2><h3 id="maegaki" class="h2"    data-line="11"  style="display:block;bookmark:1.1.&#8194;\307E \3048 \304C \304D ;level:2"><span data-line="11"></span><span class="heading-before"><span class="heading-label">1.1</span>.&#8194;</span><span data-line="11"></span>まえがき</h3>
<p class="p indent" data-line="13"><span data-line="13"></span>この記事では、関数型プログラミングにおいて動的計画法(Dynamic Programming)を行う手法の一つである <span data-line="13"></span><em class="em-star1" >dynamorphism</em><span data-line="13"></span> について解説します。
</p>
<p class="p indent" data-line="15"><span data-line="15"></span>しかし、dynamorphism という概念はそれ単体で説明できるものではなく、F-代数 や catamorphism, anamorphism, hylomorphism, histmorphism などの各種概念を用いないと説明できないものです。そこでこの記事では順々とそれらの概念を追っていき、最後にdynamorphismに行き着くような構成になっています。
</p>
<p class="p indent" data-line="17"><span data-line="17"></span>そのため、この記事は dynamorphism の説明記事であると同時に、F-(余)代数や catamorphism, anamorphism 等に関する解説記事でもあります。
</p>
<p class="p indent" data-line="19"><span data-line="19"></span>ここで留意していただきたい点が何点かあります。いわゆる予防線です。
</p>
<ul class="ul list-star loose"  data-line="21">
<li class="li ul-li list-star-li loose-li"  data-line="21">
<p data-line="21"><span data-line="21"></span>筆者はHaskellや圏論や型理論に関しては全くの素人<span data-line="21"></span><sup id="back-fn-sirouto" ><a href="#fn-sirouto" title="1.ここでいう素人とは、その分野の研究者・専門家ではない、また専門教育を受けていないことを意味します。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">1</span></a></sup><span data-line="21"></span>です。そのため今回は付け焼き刃の曖昧な知識だけで記述した箇所が多くあります。そのため、各種概念の正確な定義などに関しては文献などをあたってもらえればと思います。また、間違いを見つけたら<span data-line="21"></span><a href="http://titech-ssr.blog.jp/archives/1047835805.html#comment-form-body">ブログのコメント欄</a><span data-line="21"></span>にでも指摘していただくと幸いです。
</p></li>
<li class="li ul-li list-star-li loose-li"  data-line="23">
<p data-line="23"><span data-line="23"></span>この記事では圏論の知識はほとんど仮定しません。しかし圏論を少し知っておくと若干理解の助けになるとは思います。圏論に触れる際にオススメなのは、<span data-line="23"></span><a href="http://nineties.github.io/category-seminar/">2013年に開かれたプログラマ向けの圏論勉強会の資料</a><span data-line="23"></span>です。また、この記事全体では断りのない限りHask圏に限った話をしていきます。そのため「射」を「関数」、「対象」を「型」と表現しています。
</p></li>
<li class="li ul-li list-star-li loose-li"  data-line="25">
<p data-line="25"><span data-line="25"></span>コードの例は Haskell を用いています。実行環境は OSX (El Capitan) の GHC 7.10.2 です。
</p></li>
<li class="li ul-li list-star-li loose-li"  data-line="27">
<p data-line="27"><span data-line="27"></span>この文書は<span data-line="27"></span>&nbsp;<a href="http://madoko.net">madoko</a><span data-line="27"></span> を用いて生成されました。
</p></li></ul>

<p class="p indent" data-line="29"><span data-line="29"></span>また、先に<span data-line="29"></span><a href="http://titech-ssr.blog.jp/archives/1047298157.html">この</a><span data-line="29"></span>記事を読んでいただければと思います。<span data-line="29"></span><span class="math-inline">$1$</span><span data-line="29"></span> や <span data-line="29"></span><span class="math-inline">$A+B$</span><span data-line="29"></span>、<span data-line="29"></span><span class="math-inline">$A \times B$</span><span data-line="29"></span> などがどのような意味を持つかを知っておくと理解が容易になると思います。
</p><h3 id="kigou-ya-yougo" class="h2"    data-line="31"  style="display:block;bookmark:1.2.&#8194;\8A18 \53F7 \3084 \7528 \8A9E \306A \3069 \306E \8AAC \660E ;level:2"><span data-line="31"></span><span class="heading-before"><span class="heading-label">1.2</span>.&#8194;</span><span data-line="31"></span>記号や用語などの説明</h3>
<dl class="dl compact"  data-line="33">
<dt class="dt noindent dl-li compact-li"  style="text-indent:0em;font-weight:bold"><span class="math-inline">$1$</span></dt>
<dd class="dd"  data-line="33" style="margin-left:1.5em"><span data-line="33"></span>Unit型。何も値がない(「空」という値のみを持つ)ことを表現するために用いられます。Haskell で言う <span data-line="33"></span><code class="code code1" >()</code><span data-line="33"></span>
</dd>
<dt class="dt noindent dl-li compact-li"  style="text-indent:0em;font-weight:bold"><span class="math-inline">$A \times B$</span></dt>
<dd class="dd"  data-line="35" style="margin-left:1.5em"><span data-line="35"></span>型 <span data-line="35"></span><span class="math-inline">$A$</span><span data-line="35"></span> と 型 <span data-line="35"></span><span class="math-inline">$B$</span><span data-line="35"></span> の直積を意味します。つまり、型AとBの値両方を持つ型です。<span data-line="35"></span><strong class="strong-star2" >タプル</strong><span data-line="35"></span> と呼ばれることがあります。Haskell の場合は <span data-line="35"></span><code class="code code1" >(A,B)</code><span data-line="35"></span>。C/C++的に書くと <span data-line="35"></span><code class="code code1" >struct { A a; B b; }</code><span data-line="35"></span>。
</dd>
<dt class="dt noindent dl-li compact-li"  style="text-indent:0em;font-weight:bold"><span class="math-inline">$A + B$</span></dt>
<dd class="dd"  data-line="37" style="margin-left:1.5em"><span data-line="37"></span>型 <span data-line="37"></span><span class="math-inline">$A$</span><span data-line="37"></span> と 型 <span data-line="37"></span><span class="math-inline">$B$</span><span data-line="37"></span> の直和を意味します。つまり、型AとBの値どちらか一方を持つ型です。Haskell の場合は <span data-line="37"></span><code class="code code1" >Either A B</code><span data-line="37"></span>。C/C++的に書くと <span data-line="37"></span><code class="code code1" >union { A a; B b; }</code><span data-line="37"></span><sup id="back-fn-union" ><a href="#fn-union" title="2.実際はAとBどちらの値を持つかの情報を持っている必要があります(Tagged Union)
&#8617;" class="footnote-ref localref" ><span class="footnote-label">2</span></a></sup><span data-line="37"></span>。
</dd>
<dt class="dt noindent dl-li compact-li"  style="text-indent:0em;font-weight:bold">代数的データ型 (Algebraic Data Type)</dt>
<dd class="dd"  data-line="39" style="margin-left:1.5em"><span data-line="39"></span>直積と直和の組み合わせによって表現される型のことです。Haskell や OCaml などの他に、Rust や Swift などにも実装されています。
</dd>
<dt class="dt noindent dl-li compact-li"  style="text-indent:0em;font-weight:bold"><span class="math-inline">$f : A \to B$</span></dt>
<dd class="dd"  data-line="41" style="margin-left:1.5em"><span data-line="41"></span>Aを受け取ってBを返す関数を表します。
</dd>
<dt class="dt noindent dl-li compact-li"  style="text-indent:0em;font-weight:bold"><span class="math-inline">$\langle f, g\rangle$</span></dt>
<dd class="dd"  data-line="43" style="margin-left:1.5em"><span data-line="43"></span>任意の型 <span data-line="43"></span><span class="math-inline">$X$</span><span data-line="43"></span> に対し、<span data-line="43"></span><span class="math-inline">$f : X \to B, g : X \to B$</span><span data-line="43"></span> となるとき、<span data-line="43"></span><span class="math-inline">$\langle f, g \rangle : X \to A \times B$</span><span data-line="43"></span> となる関数が一意に定義できます。これを <span data-line="43"></span><em class="em-star1" >f</em><span data-line="43"></span> と <span data-line="43"></span><em class="em-star1" >g</em><span data-line="43"></span> の積 (product of morphism) といいます。Haskellで実装すると、<span data-line="43"></span><code class="code code1" >proj f g x = (f x, g x)</code><span data-line="43"></span>となります。
</dd>
<dt class="dt noindent dl-li compact-li"  style="text-indent:0em;font-weight:bold"><span class="math-inline">$id_A$</span></dt>
<dd class="dd"  data-line="45" style="margin-left:1.5em"><span data-line="45"></span>型 A に関する恒等写像を表します。つまり、型 A の全ての値 x に対して <span data-line="45"></span><span class="math-inline">$id_A(x) = x$</span><span data-line="45"></span> です。</dd></dl><h2 id="functor-and-fixp" class="h1"    data-line="48"  style="display:block;bookmark:2.&#8194;\95A2 \624B \3068 \4E0D \52D5 \70B9 ;level:1"><span data-line="48"></span><span class="heading-before"><span class="heading-label">2</span>.&#8194;</span><span data-line="48"></span>関手と不動点</h2>
<p class="p indent" data-line="50"><span data-line="50"></span>木やリストなどのデータ構造は、再帰的定義 (recursive definition) によって表現されます。
再帰的定義とは、自分自身を定義に含めるものを言います。例えばリストの例で言うと、
</p>
<ul class="ul list-star compact"  data-line="53">
<li class="li ul-li list-star-li compact-li"  data-line="53"><span data-line="53"></span>空リスト (nil) はリストである。
</li>
<li class="li ul-li list-star-li compact-li"  data-line="54"><span data-line="54"></span>値とリストのペア (cons) はリストである。
</li></ul>

<p class="p indent" data-line="56"><span data-line="56"></span>がリストの再帰的定義になります。 数学的(圏論的)にそのような再帰的データ構造を定式化すると、それは<span data-line="56"></span><strong class="strong-star2" >関手</strong><span data-line="56"></span>の<span data-line="56"></span><strong class="strong-star2" >不動点</strong><span data-line="56"></span>として定義されます。
ここで<span data-line="57"></span><em class="em-star1" >関手</em><span data-line="57"></span>と<span data-line="57"></span><em class="em-star1" >不動点</em><span data-line="57"></span>という概念が出てきました。それらについて見ていきましょう。
</p><h3 id="functor" class="h2"    data-line="59"  style="display:block;bookmark:2.1.&#8194;\95A2 \624B ;level:2"><span data-line="59"></span><span class="heading-before"><span class="heading-label">2.1</span>.&#8194;</span><span data-line="59"></span>関手</h3>
<p class="p indent" data-line="61"><span data-line="61"></span><strong class="strong-star2" >関手</strong><span data-line="61"></span><sup id="back-fn-func1" ><a href="#fn-func1" title="3.ここではHask圏の自己関手のことを「関手」と表記します。以下の文についても同様です。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">3</span></a></sup><span data-line="61"></span>とは、型 <span data-line="61"></span><span class="math-inline">$A$</span><span data-line="61"></span> と関数 <span data-line="61"></span><span class="math-inline">$f$</span><span data-line="61"></span> を、他の型 <span data-line="61"></span><span class="math-inline">$F(A)$</span><span data-line="61"></span> と関数 <span data-line="61"></span><span class="math-inline">$F(f)$</span><span data-line="61"></span> にマッピングするものです。このとき、関数のマッピングに関して以下の構造を保つ必要があります。
</p>
<ul class="ul list-star compact"  data-line="63">
<li class="li ul-li list-star-li compact-li"  data-line="63"><span data-line="63"></span>型 <span data-line="63"></span><span class="math-inline">$X$</span><span data-line="63"></span> に関して、<span data-line="63"></span><span class="math-inline">$ F(id_X) = id_{F(X)} $</span><span data-line="63"></span> 
</li>
<li class="li ul-li list-star-li compact-li"  data-line="64"><span data-line="64"></span>関数 <span data-line="64"></span><span class="math-inline">$f: X \to Y, g : Y \to Z$</span><span data-line="64"></span> に対して <span data-line="64"></span><span class="math-inline">$ F(g \circ f) = F(g) \circ F(f) $</span><span data-line="64"></span>
</li></ul>

<p class="p indent" data-line="66"><span data-line="66"></span>ざっくり言うと、関手とは型同士の関係を保つ写像であるといえます。Haskell ではそのまま <span data-line="66"></span><code class="code code1" >Functor</code><span data-line="66"></span> という型クラスで定義され、インスタンスとして <span data-line="66"></span><code class="code code1" >List</code><span data-line="66"></span> や <span data-line="66"></span><code class="code code1" >Maybe</code><span data-line="66"></span> などがあります。
</p>
<p class="p indent para-continue" data-line="68"><span data-line="68"></span>さて、以下の関手を考えてみましょう。ここで、Intは整数型です。
</p>
<div id="fx" class="equation para-block"  data-line="69" style="line-adjust:0"><span data-line="69"></span><span class="equation-before" ><span class="equation-label">(1)</span></span><span data-line="69"></span>

<div class="mathdisplay para-block input-math"   data-line="70" style="line-adjust:0"><span class="mathdisplay math-display"  >\[F(X) := 1 + Int \times X 
\]</span></div></div>
<p class="p indent para-continued" data-line="72"><span data-line="72"></span>これをHaskellのコードで表すと以下のようになります。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="73" data-line-first="74" ><code data-line="74"><span class='token comment haskell'>{-</span><span class='token comment haskell'> Nil が 1 を、Cons Int x が Int × X を表現している</span><span class='token comment haskell'>-}</span><br><span class='token keyword haskell'>data</span> <span class='token type identifier haskell'>F</span> <span class='token type identifier typevar haskell'>x</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>Nil</span> <span class='token keyword operator haskell'>|</span> <span class='token constructor haskell'>Cons</span> <span class='token type identifier haskell'>Int</span> <span class='token type identifier typevar haskell'>x</span><br><br><span class='token comment haskell'>{-</span><span class='token comment haskell'> Fを関手のインスタンスにするための宣言、関数についてのマッピング </span><span class='token comment haskell'>-}</span><br><span class='token keyword haskell'>instance</span> <span class='token type identifier haskell'>Functor</span> <span class='token type identifier haskell'>F</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>fmap</span> <span class='token identifier haskell'>f</span> <span class='token constructor haskell'>Nil</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>Nil</span><br>  <span class='token identifier haskell'>fmap</span> <span class='token identifier haskell'>f</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Cons</span> <span class='token identifier haskell'>x</span> <span class='token identifier haskell'>xs</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>Cons</span> <span class='token identifier haskell'>x</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>f</span> <span class='token identifier haskell'>xs</span><span class='token delimiter parenthesis haskell bracket-close'>)</span></code></pre>
<p class="p indent para-continued" data-line="83"><span data-line="83"></span>以下の例を見れば分かる通り、<span data-line="83"></span><span class="math-inline">$F(X)$</span><span data-line="83"></span> は一種のリストに対するコンストラクタ(構成子)となっています。
<span data-line="84"></span><span class="math-inline">$Int \times X$</span><span data-line="84"></span> が Cons ペア、<span data-line="84"></span><span class="math-inline">$1$</span><span data-line="84"></span>が nil (リストの終端) を表現しています。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="86" data-line-first="87" ><code data-line="87"><span class='token constructor haskell'>Nil</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>F</span> <span class='token type identifier typevar haskell'>a</span><br><span class='token type identifier haskell'>Cons</span> <span class='token number haskell'>1</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>Nil</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>F</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier haskell'>F</span> <span class='token type identifier typevar haskell'>a</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span><br><span class='token type identifier haskell'>Cons</span> <span class='token number haskell'>1</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>Cons</span> <span class='token number haskell'>2</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>Nil</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>F</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier haskell'>F</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier haskell'>F</span> <span class='token type identifier typevar haskell'>a</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span><br><span class='token type identifier haskell'>Cons</span> <span class='token number haskell'>1</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>Cons</span> <span class='token number haskell'>2</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>Cons</span> <span class='token number haskell'>3</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>Nil</span> <span class='token type operator haskell'>::</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier haskell'>F</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier haskell'>F</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier haskell'>F</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier haskell'>F</span> <span class='token type identifier typevar haskell'>a</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span></code></pre>
<p class="p indent para-continued" data-line="93"><span data-line="93"></span>しかし、このままではリストのサイズによって型が変わってしまいますし、型変数 <span data-line="93"></span><code class="code code1" >a</code><span data-line="93"></span> も残ったままです。
これを避けるために<span data-line="94"></span><em class="em-star1" >不動点</em><span data-line="94"></span>の概念を導入します。
</p><h3 id="fixp" class="h2"    data-line="96"  style="display:block;bookmark:2.2.&#8194;\4E0D \52D5 \70B9 ;level:2"><span data-line="96"></span><span class="heading-before"><span class="heading-label">2.2</span>.&#8194;</span><span data-line="96"></span>不動点</h3>
<p class="p indent para-continue" data-line="98"><span data-line="98"></span>そもそもリストを関手で表現したいならば、こう定義した方がよさそうに見えます。
</p>
<div id="sflist" class="equation para-block"  data-line="100" style="line-adjust:0"><span data-line="100"></span><span class="equation-before" ><span class="equation-label">(2)</span></span><span data-line="100"></span>

<div class="mathdisplay para-block input-math"   data-line="101" style="line-adjust:0"><span class="mathdisplay math-display"  >\[  {\sf List} := 1 + Int \times {\sf List}
\]</span></div></div>
<p class="p indent para-continued" data-line="104"><span data-line="104"></span>しかしこれでは定義自身に<span data-line="104"></span><span class="math-inline">${\sf List}$</span><span data-line="104"></span> が含まれる、いわゆる再帰的定義となってしまいます。
</p>
<p class="p indent" data-line="106"><span data-line="106"></span>そこで、<span data-line="106"></span><a href="#sflist" class="localref" style="target-element:equation"><span class="equation-label">(2)</span></a><span data-line="106"></span>を「方程式」とみなし、その方程式を満たすような <span data-line="106"></span><span class="math-inline">${\sf List}$</span><span data-line="106"></span> を「リストを表すデータ型」とする発想の転換をします。しかし、型同士の等式は <span data-line="106"></span><span class="math-inline">$=$</span><span data-line="106"></span> ではなく 同型 <span data-line="106"></span><span class="math-inline">$ \simeq $</span><span data-line="106"></span> で結びます。 
</p>
<div class="note"  data-line="108" style="display:block">
<p class="p indent" data-line="109"><span data-line="109"></span><span class="note-before"><strong class="strong-star2" ><span class="note-caption">Note</span></strong>.
</span><span data-line="110"></span>型 <span data-line="110"></span><span class="math-inline">$A, B$</span><span data-line="110"></span> に対してA <span data-line="110"></span><span class="math-inline">$\simeq$</span><span data-line="110"></span> B とは、「関数 <span data-line="110"></span><span class="math-inline">$f: A \to B, g: B \to A$</span><span data-line="110"></span> が存在し、<span data-line="110"></span><span class="math-inline">$f \circ g = g \circ f = id$</span><span data-line="110"></span> である」ということです。なお、f, g はそれぞれ存在すれば一意に定まります。</p></div>
<p class="p indent para-continue" data-line="112"><span data-line="112"></span>つまり、次の「方程式」を満たすような <span data-line="112"></span><span class="math-inline">$X$</span><span data-line="112"></span> が「リストを表すデータ型」です。
</p>
<div id="eqn1" class="equation para-block"  data-line="114" style="line-adjust:0"><span data-line="114"></span><span class="equation-before" ><span class="equation-label">(3)</span></span><span data-line="114"></span>

<div class="mathdisplay para-block input-math"   data-line="115" style="line-adjust:0"><span class="mathdisplay math-display"  >\[  X \simeq 1 + Int \times X
\]</span></div></div>
<p class="p indent para-continued para-continue" data-line="118"><span data-line="118"></span>ここで、<span data-line="118"></span><a href="#fx" class="localref" style="target-element:equation"><span class="equation-label">(1)</span></a><span data-line="118"></span>より、<span data-line="118"></span><a href="#eqn1" class="localref" style="target-element:equation"><span class="equation-label">(3)</span></a><span data-line="118"></span>は次のように書けます。
</p>
<div id="eqn2" class="equation para-block"  data-line="120" style="line-adjust:0"><span data-line="120"></span><span class="equation-before" ><span class="equation-label">(4)</span></span><span data-line="120"></span>

<div class="mathdisplay para-block input-math"   data-line="121" style="line-adjust:0"><span class="mathdisplay math-display"  >\[  X \simeq F(X)
\]</span></div></div>
<p class="p indent para-continued" data-line="124"><span data-line="124"></span>この時、<span data-line="124"></span><a href="#eqn2" class="localref" style="target-element:equation"><span class="equation-label">(4)</span></a><span data-line="124"></span>を満たすような <span data-line="124"></span><span class="math-inline">$X$</span><span data-line="124"></span> のことを関手<span data-line="124"></span><span class="math-inline">$F$</span><span data-line="124"></span>の<span data-line="124"></span><strong class="strong-star2" >不動点</strong><span data-line="124"></span> とよび、<span data-line="124"></span><span class="math-inline">$\mu F$</span><span data-line="124"></span> で表します。<span data-line="124"></span><sup id="back-fn-fixedf" ><a href="#fn-fixedf" title="4.つまり、$\mu F$ について、$f: \mu F \to F(\mu F)$ と $g: F(\mu F) \to \mu F$ が一意に存在し、$f \circ g = id_{F(\mu F)}, g \circ f = id_{\mu F}$を満たすことを意味します。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">4</span></a></sup><span data-line="124"></span>そして <span data-line="124"></span><span class="math-inline">$\mu F$</span><span data-line="124"></span> こそがまさに求めたい <span data-line="124"></span><em class="em-star1" >リストを表現するデータ型</em><span data-line="124"></span> となっています。
</p>
<p class="p indent" data-line="126"><span data-line="126"></span>以下、Haskellへ不動点を導入した上で、先述の<span data-line="126"></span><code class="code code1" >F</code><span data-line="126"></span>に関して不動点を適用して、実際にリストを表現することを確認します。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="128" data-line-first="129" ><code data-line="129"><span class='token comment haskell'>{-</span><span class='token comment haskell'> 関手 f について不動点を取る</span><br><span class='token comment haskell'>  ここで、 inF  :: f (FixF f) </span><span class='token comment haskell'>-</span><span class='token comment haskell'>&gt; FixF f</span><br><span class='token comment haskell'>                 outF :: FixF f     </span><span class='token comment haskell'>-</span><span class='token comment haskell'>&gt; f (FixF f)</span><br><span class='token comment haskell'>  であり、inF . outF = id, outF . inF = id</span><br><span class='token comment haskell'>  よって同型の定義より f について不動点を取れている。</span><span class='token comment haskell'>-}</span><br><span class='token keyword haskell'>newtype</span> <span class='token constructor haskell'>FixF</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>InF</span> <span class='token delimiter curly haskell bracket-open'>{</span> <span class='token identifier haskell'>outF</span> <span class='token type operator haskell'>::</span> <span class='token type identifier typevar haskell'>f</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier haskell'>FixF</span> <span class='token type identifier typevar haskell'>f</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span> <span class='token delimiter curly haskell bracket-close'>}</span><br><br><span class='token comment haskell'>{-</span><span class='token comment haskell'> IntList = (F の不動点) </span><span class='token comment haskell'>-}</span><br><span class='token keyword haskell'>type</span> <span class='token type identifier haskell'>IntList</span> <span class='token keyword haskell'>=</span> <span class='token type identifier haskell'>FixF</span> <span class='token type identifier haskell'>F</span><br><br><span class='token comment haskell'>{-</span><span class='token comment haskell'> IntList を構成する補助関数 </span><span class='token comment haskell'>-}</span><br><span class='token identifier haskell'>nil</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>IntList</span><br><span class='token identifier haskell'>nil</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>InF</span> <span class='token constructor haskell'>Nil</span><br><span class='token identifier haskell'>cons</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>Int</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>IntList</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>IntList</span><br><span class='token identifier haskell'>cons</span> <span class='token identifier haskell'>a</span> <span class='token identifier haskell'>as</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>InF</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>Cons</span> <span class='token identifier haskell'>a</span> <span class='token identifier haskell'>as</span><br><br><span class='token identifier haskell'>a0</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>nil</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>IntList</span><br><span class='token identifier haskell'>a1</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>cons</span> <span class='token number haskell'>1</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>nil</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>IntList</span><br><span class='token identifier haskell'>a2</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>cons</span> <span class='token number haskell'>1</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>cons</span> <span class='token number haskell'>2</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>nil</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>IntList</span><br><span class='token identifier haskell'>a3</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>cons</span> <span class='token number haskell'>1</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>cons</span> <span class='token number haskell'>2</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>cons</span> <span class='token number haskell'>3</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>nil</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>IntList</span></code></pre>
<p class="p indent para-continued" data-line="151"><span data-line="151"></span>これで任意長の長さのリストを型 <span data-line="151"></span><code class="code code1" >IntList = FixF F</code><span data-line="151"></span> にまとめる事ができました。
つまり、<span data-line="152"></span><strong class="strong-star2" >関手</strong><span data-line="152"></span> <span data-line="152"></span><span class="math-inline">$F$</span><span data-line="152"></span> の<span data-line="152"></span><strong class="strong-star2" >不動点</strong><span data-line="152"></span> <span data-line="152"></span><span class="math-inline">$\mu F$</span><span data-line="152"></span> を取ることによって <span data-line="152"></span><em class="em-star1" >任意の長さのリストを表現するデータ型</em><span data-line="152"></span> が作れました。
</p><h2 id="sec-catamorphism-anamorphism" class="h1"    data-line="154"  style="display:block;bookmark:3.&#8194;catamorphism \3068  anamorphism;level:1"><span data-line="154"></span><span class="heading-before"><span class="heading-label">3</span>.&#8194;</span><span data-line="154"></span>catamorphism と anamorphism</h2>
<p class="p indent" data-line="156"><span data-line="156"></span>この章では <span data-line="156"></span><strong class="strong-star2" >catamorphism</strong><span data-line="156"></span> と <span data-line="156"></span><strong class="strong-star2" >anamorphism</strong><span data-line="156"></span> について説明します。 catamorphism は、関数型プログラミングでいう fold の一般化であり、データ構造を畳み込んで1つの値にする処理のことを表現しています。anamorphism はそれとは逆に、1つの値からデータ構造を構築する処理のことを表します。
</p>
<p class="p indent" data-line="158"><span data-line="158"></span>catamorphism, anamorphism について定式化するため、<span data-line="158"></span><strong class="strong-star2" >代数</strong><span data-line="158"></span>と<span data-line="158"></span><strong class="strong-star2" >余代数</strong><span data-line="158"></span>という概念を導入します。これは圏論に由来するものであり、若干抽象的な話題になってきます。そこで、<span data-line="158"></span><a href="https://ja.wikipedia.org/wiki/可換図式">可換図式</a><span data-line="158"></span>をいくつか載せました。可換図式によって何となくでも良いのでイメージを掴んでもらえればと思います。
</p><h3 id="sec-catamorphism" class="h2"    data-line="160"  style="display:block;bookmark:3.1.&#8194;\4EE3 \6570 \3068 catamorphism;level:2"><span data-line="160"></span><span class="heading-before"><span class="heading-label">3.1</span>.&#8194;</span><span data-line="160"></span>代数とcatamorphism</h3>
<p class="p indent" data-line="162"><span data-line="162"></span>関手 <span data-line="162"></span><span class="math-inline">$F$</span><span data-line="162"></span> について、型 <span data-line="162"></span><span class="math-inline">$A$</span><span data-line="162"></span> と、関数 <span data-line="162"></span><span class="math-inline">$f : F(A) \to A$</span><span data-line="162"></span> のペア <span data-line="162"></span><span class="math-inline">$(A, f)$</span><span data-line="162"></span> を <span data-line="162"></span><strong class="strong-star2" ><span class="math-inline">$F$</span>-代数</strong><span data-line="162"></span> (F-algebra) といいます。
また、F-代数 <span data-line="163"></span><span class="math-inline">$(A, a : F(A) \to A), (B, b : F(B) \to B)$</span><span data-line="163"></span> に対し、<span data-line="163"></span><span class="math-inline">$f : A \to B$</span><span data-line="163"></span> で <span data-line="163"></span><span class="math-inline">$f \circ a = b \circ F(f)$</span><span data-line="163"></span> を満たすものを<span data-line="163"></span><strong class="strong-star2" >F-代数の準同型</strong><span data-line="163"></span> (homomorphism of F-algebra) といいます。すなわち、以下の図式を可換にします。(可換図式において、始点と終点が同じと成るような道は、全て合成によって同じ結果になることを示します。)
</p>
<div class="center align-center" data-line="165" style="text-align:center">
<p class="p indent" data-line="166"><span data-line="166"></span><img src="diagrams/fig1.png" alt="fig-alg" data-path="diagrams/fig1.png" data-linkid="fig-alg" style="height:150px"></p></div>
<p class="p indent" data-line="169"><span data-line="169"></span>例として <span data-line="169"></span><span class="math-inline">$ F(X) = 1 + {\rm Int} \times X $</span><span data-line="169"></span> のF-代数を挙げます。ここで <span data-line="169"></span><span class="math-inline">$A = {\rm Int}$</span><span data-line="169"></span>として F-代数 <span data-line="169"></span><span class="math-inline">$(A,f)$</span><span data-line="169"></span> を考えると、関数 f の型は <span data-line="169"></span><span class="math-inline">$F({\rm Int}) \to {\rm Int} $</span><span data-line="169"></span> つまり <span data-line="169"></span><span class="math-inline">$ 1 + {\rm Int} \times {\rm Int} \to {\rm Int}$</span><span data-line="169"></span> となります。f としては以下の様な関数 plus が考えられます。もちろんこれ以外にも様々な f の実装が考えられます。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="171" data-line-first="172" ><code data-line="172"><span class='token identifier haskell'>plus</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>F</span> <span class='token type identifier haskell'>Int</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>Int</span><br><span class='token identifier haskell'>plus</span> <span class='token constructor haskell'>Nil</span> <span class='token keyword operator haskell'>=</span> <span class='token number haskell'>0</span><br><span class='token identifier haskell'>plus</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Cons</span> <span class='token identifier haskell'>a</span> <span class='token identifier haskell'>b</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>a</span> <span class='token operator haskell'>+</span> <span class='token identifier haskell'>b</span></code></pre>
<p class="p indent para-continued" data-line="177"><span data-line="177"></span>特にF-代数の中で、任意の他のF-代数への準同型が一意に存在するものを <span data-line="177"></span><strong class="strong-star2" >F-始代数</strong><span data-line="177"></span> (initial F-algebra) といいます。<span data-line="177"></span><sup id="back-fn-falg" ><a href="#fn-falg" title="5.要するに (F,f) を対象、準同型を射とする圏 ${\mathcal Alg}(F)$ の始対象がF-始代数。また、F-始代数は(存在すれば)同型を除いて一意。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">5</span></a></sup><span data-line="177"></span> つまり、先の図において、任意の型 <span data-line="177"></span><span class="math-inline">$B$</span><span data-line="177"></span> に対し <span data-line="177"></span><span class="math-inline">$f$</span><span data-line="177"></span> が一意に存在する場合、<span data-line="177"></span><span class="math-inline">$A$</span><span data-line="177"></span>はF-始代数になります。
</p>
<p class="p indent" data-line="179"><span data-line="179"></span>さて、実は <span data-line="179"></span><span class="math-inline">$(\mu F, {\sf inF})$</span><span data-line="179"></span> は F-始代数であることが知られています。<span data-line="179"></span><sup id="back-fn-initialf" ><a href="#fn-initialf" title="6.実は「$(\mu F, {\sf inF})$ が始代数であるならば、$\mu F$ は不動点である」というLambekの定理をもとに始対象から不動点である事実を導いているのですが、ここでは説明の流れが逆(不動点→始対象)になっています。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">6</span></a></sup><span data-line="179"></span>つまり、任意のF-代数 <span data-line="179"></span><span class="math-inline">$(X, \varphi : F(X) \to X)$</span><span data-line="179"></span> に対して関数 <span data-line="179"></span><span class="math-inline">$f : \mu F \to X$</span><span data-line="179"></span> が一意に存在します。この時、<span data-line="179"></span><span class="math-inline">$f$</span><span data-line="179"></span> のことを <span data-line="179"></span><strong class="strong-star2" >catamorphism</strong><span data-line="179"></span> <span data-line="179"></span><sup id="back-fn-cata" ><a href="#fn-cata" title="9.日本語訳は知るかぎりではありません。無理やり訳すなら「下射」みたいな？
&#8617;" class="footnote-ref localref" ><span class="footnote-label">9</span></a></sup><span data-line="179"></span> と呼びます。また、<span data-line="179"></span><span class="math-inline">$f$</span><span data-line="179"></span> を <span data-line="179"></span><span class="math-inline">${\sf cata} \varphi$</span><span data-line="179"></span> や <span data-line="179"></span><span class="math-inline">$ (\!| \varphi |\!) $</span><span data-line="179"></span> と表すこともあります。
</p>
<div class="center align-center" data-line="181" style="text-align:center">
<p class="p indent" data-line="182"><span data-line="182"></span><img src="diagrams/fig2.png" alt="fig-cata" data-path="diagrams/fig2.png" data-linkid="fig-cata" style="height:150px"></p></div>
<p class="p indent para-continue" data-line="185"><span data-line="185"></span>図式が示すように、catamorphism は以下のように表現できます。
</p>
<div class="equation para-block"  data-line="187" style="line-adjust:0"><span data-line="187"></span><span class="equation-before" ><span class="equation-label">(5)</span></span><span data-line="187"></span>

<div class="mathdisplay para-block input-math"   data-line="188" style="line-adjust:0"><span class="mathdisplay math-display"  >\[{\sf cata} \varphi = \varphi \circ F({\sf cata} \varphi) \circ {\sf outF}
\]</span></div></div>
<p class="p indent para-continued" data-line="191"><span data-line="191"></span>これをHaskellのコードにすると以下のようになります。引数として関数 <span data-line="191"></span><span class="math-inline">$ \varphi : F(A) \to A $</span><span data-line="191"></span> を受け取り「<span data-line="191"></span><span class="math-inline">$\mu F$</span><span data-line="191"></span> を受け取り A を返す関数」を返す、高階関数になっています。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="193" data-line-first="194" ><code data-line="194"><span class='token identifier haskell'>cata</span> <span class='token type operator haskell'>::</span> <span class='token constructor haskell'>Functor</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>=&gt;</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token constructor haskell'>FixF</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>a</span><br><span class='token identifier haskell'>cata</span> <span class='token identifier haskell'>phi</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>phi</span> <span class='token operator haskell'>.</span> <span class='token identifier haskell'>fmap</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>cata</span> <span class='token identifier haskell'>phi</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token operator haskell'>.</span> <span class='token identifier haskell'>outF</span></code></pre>
<p class="p indent para-continued" data-line="198"><span data-line="198"></span><em class="em-star1" >catamorphism は、いわゆる関数型プログラミングにおける fold の一般化です。</em><span data-line="198"></span>関手<span data-line="198"></span><span class="math-inline">$F$</span><span data-line="198"></span> がリストを構成するならリストの畳込みを意味し、木を構成するなら木の畳み込みを意味します。
つまり、catamorphismは関手<span data-line="199"></span><span class="math-inline">$F$</span><span data-line="199"></span>によって構成されたデータ構造を次々と畳み込んで、一つの値に収束させることを意味しています。
</p>
<p class="p indent" data-line="201"><span data-line="201"></span>catamorphism を使ってリストの畳込みをしてみます。
既にこれまで定義した関数や型を用いています。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="204" data-line-first="205" ><code data-line="205"><span class='token comment haskell'>-- リストの総和を求める関数</span><br><span class='token identifier haskell'>sumIL</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>IntList</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>Int</span><br><span class='token identifier haskell'>sumIL</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>cata</span> <span class='token identifier haskell'>plus</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>plus</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>F</span> <span class='token type identifier haskell'>Int</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>Int</span><br>  <span class='token identifier haskell'>plus</span> <span class='token constructor haskell'>Nil</span> <span class='token keyword operator haskell'>=</span> <span class='token number haskell'>0</span><br>  <span class='token identifier haskell'>plus</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Cons</span> <span class='token identifier haskell'>a</span> <span class='token identifier haskell'>b</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>a</span> <span class='token operator haskell'>+</span> <span class='token identifier haskell'>b</span><br>  <span class='token comment haskell'>-- ここで a は 今見ているリストの先頭、b はこれまでの畳込みの結果を表している</span><br><br><span class='token comment haskell'>{-</span><br><span class='token comment haskell'>main = print $ sumIL $ cons 100 $ cons 20 $ cons 3 $ nil</span><br><span class='token comment haskell'>出力: 123</span><br><span class='token comment haskell'>-}</span></code></pre>
<p class="p indent para-continued" data-line="219"><span data-line="219"></span>この時の状況は以下のようになっています。
</p>
<div class="center align-center" data-line="221" style="text-align:center">
<p class="p indent" data-line="222"><span data-line="222"></span><img src="diagrams/fig3.png" alt="fig-sum" data-path="diagrams/fig3.png" data-linkid="fig-sum" style="height:150px"></p></div><h3 id="sec-anamorphism" class="h2"    data-line="225"  style="display:block;bookmark:3.2.&#8194;\4F59 \4EE3 \6570 \3068 anamorphism;level:2"><span data-line="225"></span><span class="heading-before"><span class="heading-label">3.2</span>.&#8194;</span><span data-line="225"></span>余代数とanamorphism</h3>
<p class="p indent" data-line="227"><span data-line="227"></span><strong class="strong-star2" >余代数</strong><span data-line="227"></span>(coalgebra)とは、代数の双対です。つまり、先ほどの可換図式の矢印を反対したものが、そのまま余代数になります。
</p>
<p class="p indent" data-line="229"><span data-line="229"></span>一応定義を書いておきます。関手 <span data-line="229"></span><span class="math-inline">$F$</span><span data-line="229"></span> について、型 <span data-line="229"></span><span class="math-inline">$A$</span><span data-line="229"></span> と、関数 <span data-line="229"></span><span class="math-inline">$f : F(A) \to A$</span><span data-line="229"></span> のペア <span data-line="229"></span><span class="math-inline">$(A, f)$</span><span data-line="229"></span> を <span data-line="229"></span><strong class="strong-star2" ><span class="math-inline">$F$</span>-余代数</strong><span data-line="229"></span> (F-coalgebra) といいます。
また、F-余代数 <span data-line="230"></span><span class="math-inline">$(A, a : A \to F(A)), (B, b : B \to F(B))$</span><span data-line="230"></span> に対し、<span data-line="230"></span><span class="math-inline">$f : A \to B$</span><span data-line="230"></span> で <span data-line="230"></span><span class="math-inline">$F(f) \circ a = b \circ f$</span><span data-line="230"></span> を満たすものを<span data-line="230"></span><strong class="strong-star2" >F-余代数の準同型</strong><span data-line="230"></span> (homomorphism of F-coalgebra) といいます。すなわち、以下の図式を可換にします。
</p>
<div class="center align-center" data-line="232" style="text-align:center">
<p class="p indent" data-line="233"><span data-line="233"></span><img src="diagrams/fig4.png" alt="fig-coalg" data-path="diagrams/fig4.png" data-linkid="fig-coalg" style="height:150px"></p></div>
<p class="p indent" data-line="236"><span data-line="236"></span>特にF-余代数の中で、任意の他のF-余代数<span data-line="236"></span><strong class="strong-star2" >から</strong><span data-line="236"></span>の準同型が一意に存在するものを <span data-line="236"></span><strong class="strong-star2" >F-終余代数</strong><span data-line="236"></span> (terminal F-coalgebra) といいます。<span data-line="236"></span><sup id="back-fn-fcoalg" ><a href="#fn-fcoalg" title="7.要するに (F,f) を対象、準同型を射とする圏 ${\mathcal CoAlg}(F)$ の終対象がF-終余代数。また、F-終余代数は(存在すれば)同型を除いて一意。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">7</span></a></sup><span data-line="236"></span> つまり、先の図において、任意の型 <span data-line="236"></span><span class="math-inline">$A$</span><span data-line="236"></span> に対し <span data-line="236"></span><span class="math-inline">$f$</span><span data-line="236"></span> が一意に存在する場合、<span data-line="236"></span><span class="math-inline">$B$</span><span data-line="236"></span>はF-終余代数になります。
</p>
<p class="p indent" data-line="239"><span data-line="239"></span>先程と同様に、<span data-line="239"></span><span class="math-inline">$(\mu F, {\sf outF})$</span><span data-line="239"></span> は F-終余代数であることが知られています。<span data-line="239"></span><sup id="back-fn-terminalf" ><a href="#fn-terminalf" title="8.この時、正確には終余代数となるのは最大不動点 $\nu F$ ですが、言及している状況下では、最大不動点と最小不動点は一致するので$\mu F$としています。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">8</span></a></sup><span data-line="239"></span>つまり、任意のF-余代数 <span data-line="239"></span><span class="math-inline">$(Y, \psi : Y \to F(Y))$</span><span data-line="239"></span> に対して関数 <span data-line="239"></span><span class="math-inline">$f : Y \to \mu F$</span><span data-line="239"></span> が一意に存在します。この時、<span data-line="239"></span><span class="math-inline">$f$</span><span data-line="239"></span> のことを <span data-line="239"></span><strong class="strong-star2" >anamorphism</strong><span data-line="239"></span> <span data-line="239"></span><sup id="back-fn-ana" ><a href="#fn-ana" title="10.無理やり訳すなら「上射」です。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">10</span></a></sup><span data-line="239"></span> と呼びます。また、<span data-line="239"></span><span class="math-inline">$f$</span><span data-line="239"></span> を <span data-line="239"></span><span class="math-inline">${\sf ana} \psi$</span><span data-line="239"></span> や <span data-line="239"></span><span class="math-inline">$ [\!( \psi )\!] $</span><span data-line="239"></span> と表すこともあります。
</p>
<div class="center align-center" data-line="241" style="text-align:center">
<p class="p indent" data-line="242"><span data-line="242"></span><img src="diagrams/fig5.png" alt="fig-ana" data-path="diagrams/fig5.png" data-linkid="fig-ana" style="height:150px"></p></div>
<p class="p indent para-continue" data-line="245"><span data-line="245"></span>図式が示すように、anamorphism は以下のように表現できます。
</p>
<div class="equation para-block"  data-line="247" style="line-adjust:0"><span data-line="247"></span><span class="equation-before" ><span class="equation-label">(6)</span></span><span data-line="247"></span>

<div class="mathdisplay para-block input-math"   data-line="248" style="line-adjust:0"><span class="mathdisplay math-display"  >\[{\sf ana} \psi = {\sf inF} \circ F({\sf ana} \psi) \circ \psi
\]</span></div></div>
<p class="p indent para-continued" data-line="251"><span data-line="251"></span>Haskell のコードで実装すると以下のようになります。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="253" data-line-first="254" ><code data-line="254"><span class='token identifier haskell'>ana</span> <span class='token type operator haskell'>::</span> <span class='token constructor haskell'>Functor</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>=&gt;</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>a</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>a</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token constructor haskell'>FixF</span> <span class='token identifier haskell'>f</span><br><span class='token identifier haskell'>ana</span> <span class='token identifier haskell'>psi</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>InF</span> <span class='token operator haskell'>.</span> <span class='token identifier haskell'>fmap</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>ana</span> <span class='token identifier haskell'>psi</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token operator haskell'>.</span> <span class='token identifier haskell'>psi</span></code></pre>
<p class="p indent para-continued" data-line="258"><span data-line="258"></span>catamorphism が 「データ構造を畳み込んで一つの値にしていくもの」ものとは逆に、anamorphism は「一つの値からデータ構造を<span data-line="258"></span><em class="em-star1" >構築</em><span data-line="258"></span>していくもの」といえます。つまり、ある初期値 <span data-line="258"></span><span class="math-inline">$a$</span><span data-line="258"></span> (seed と呼ばれることがあります) が <span data-line="258"></span><span class="math-inline">${\sf ana} \psi$</span><span data-line="258"></span> に与えられると、<span data-line="258"></span><span class="math-inline">$\psi$</span><span data-line="258"></span> が次々に適用され、無限(もしくは有限)の大きさのリストや木などのデータ構造が得られます。
Haskell ではリストに対する anamorphism として<span data-line="259"></span>&nbsp;<a href="https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#g:9">unfoldr</a><span data-line="259"></span> というものが Data.List に定義されています。
</p>
<p class="p indent" data-line="261"><span data-line="261"></span>さて、anamorphism の例を見てみましょう。ここでは0からn-1まで1ずつ増加していくリストを構築する関数 iota を考えてみます。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="263" data-line-first="264" ><code data-line="264"><span class='token identifier haskell'>iota</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>Int</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>IntList</span><br><span class='token identifier haskell'>iota</span> <span class='token identifier haskell'>n</span> <span class='token keyword operator haskell'>=</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>ana</span> <span class='token identifier haskell'>psi</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token number haskell'>0</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>psi</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>Int</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>F</span> <span class='token type identifier haskell'>Int</span><br>  <span class='token identifier haskell'>psi</span> <span class='token identifier haskell'>i</span> <span class='token keyword operator haskell'>=</span> <span class='token keyword haskell'>if</span> <span class='token identifier haskell'>i</span> <span class='token operator haskell'>==</span> <span class='token identifier haskell'>n</span> <span class='token keyword haskell'>then</span> <span class='token constructor haskell'>Nil</span><br>                    <span class='token keyword haskell'>else</span> <span class='token constructor haskell'>Cons</span> <span class='token identifier haskell'>i</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>i</span> <span class='token operator haskell'>+</span> <span class='token number haskell'>1</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br>  <span class='token comment haskell'>-- Cons の第一引数はリストの要素の値、第二引数は次のphiの引数に渡す値となる</span><br><br><span class='token comment haskell'>--- iota 3 == cons 0 $ cons 1 $ cons 2 $ nil</span></code></pre><h2 id="sec-hylomorphism" class="h1"    data-line="274"  style="display:block;bookmark:4.&#8194;hylomorphism;level:1"><span data-line="274"></span><span class="heading-before"><span class="heading-label">4</span>.&#8194;</span><span data-line="274"></span>hylomorphism</h2>
<p class="p indent para-continue" data-line="276"><span data-line="276"></span><strong class="strong-star2" >hylomorphism</strong><span data-line="276"></span> とは、まず anamorphism によってデータ構造を構築し、catamorphism により生成したデータ構造を畳み込んで一つの値にする一連の処理を行う関数です。これは2つの合成関数として表現できます。
</p>
<div id="hylodef" class="equation para-block"  data-line="278" style="line-adjust:0"><span data-line="278"></span><span class="equation-before" ><span class="equation-label">(7)</span></span><span data-line="278"></span>

<div class="mathdisplay para-block input-math"   data-line="279" style="line-adjust:0"><span class="mathdisplay math-display"  >\[{\sf hylo} (\varphi, \psi) = {\sf cata} \varphi \circ {\sf ana} \psi
\]</span></div></div>
<p class="p indent para-continued" data-line="282"><span data-line="282"></span>これを図式に表すと以下のようになります。
</p>
<div class="center align-center" data-line="284" style="text-align:center">
<p class="p indent" data-line="285"><span data-line="285"></span><img src="diagrams/fig6.png" alt="fig-hylo" data-path="diagrams/fig6.png" data-linkid="fig-hylo" style="height:300px"></p></div>
<p class="p indent para-continue" data-line="288"><span data-line="288"></span>図式を見てわかるように、hyloは以下のようにも書けます。
</p>
<div class="equation para-block"  data-line="289" style="line-adjust:0"><span data-line="289"></span><span class="equation-before" ><span class="equation-label">(8)</span></span><span data-line="289"></span>

<div class="mathdisplay para-block input-math"   data-line="290" style="line-adjust:0"><span class="mathdisplay math-display"  >\[{\sf hylo} (\varphi, \psi) = \varphi \circ F({\sf hylo} (\varphi, \psi)) \circ \psi
\]</span></div></div>
<p class="p indent para-continued" data-line="293"><span data-line="293"></span>さて、hyloをHaskellに実装すると以下のようになります。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="295" data-line-first="296" ><code data-line="296"><span class='token identifier haskell'>hylo</span> <span class='token type operator haskell'>::</span> <span class='token constructor haskell'>Functor</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>=&gt;</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>f</span> <span class='token identifier haskell'>x</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>x</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>y</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>y</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>y</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>x</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br><span class='token identifier haskell'>hylo</span> <span class='token identifier haskell'>phi</span> <span class='token identifier haskell'>psi</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>cata</span> <span class='token identifier haskell'>phi</span> <span class='token operator haskell'>.</span> <span class='token identifier haskell'>ana</span> <span class='token identifier haskell'>psi</span></code></pre>
<p class="p indent para-continued" data-line="301"><span data-line="301"></span>hylomorphism によって、再帰関数の処理が表現できます。再帰関数の呼び出しは、<span data-line="301"></span><a href="https://en.wikibooks.org/wiki/Visualizing_Computation/Call_Trees">call treeという木構造で表現できます</a><span data-line="301"></span>。そのため、<span data-line="301"></span><span class="math-inline">${\sf ana} \varphi$</span><span data-line="301"></span>で引数の値に基づきそのcall treeを再現し、さらにその tree を evaluation する処理を <span data-line="301"></span><span class="math-inline">${\sf cata} \psi$</span><span data-line="301"></span> で行えば、再帰関数と同等の処理が可能になります。
</p>
<p class="p indent" data-line="303"><span data-line="303"></span>では再帰関数の例としてフィボナッチ数列のn番目を求める関数 <span data-line="303"></span><span class="math-inline">$fib(n)$</span><span data-line="303"></span> をhyloで実現しましょう。この時 hylo のベースになる関手 <span data-line="303"></span><span class="math-inline">$F_{fib}(X)$</span><span data-line="303"></span> は、<span data-line="303"></span><span class="math-inline">$F_{fib}(X) = 1 + 1 + Int \times X \times X$</span><span data-line="303"></span> となります。 
</p>
<p class="p indent" data-line="305"><span data-line="305"></span>この時 <span data-line="305"></span><span class="math-inline">$1 + 1$</span><span data-line="305"></span> は再帰関数の「底」、つまり <span data-line="305"></span><span class="math-inline">$fib(0) = 0$</span><span data-line="305"></span> と <span data-line="305"></span><span class="math-inline">$fib(1) = 1$</span><span data-line="305"></span> を意味しています。また、<span data-line="305"></span><span class="math-inline">$X \times X$</span><span data-line="305"></span> は <span data-line="305"></span><span class="math-inline">$fib(n) = fib(n-1) + fib(n-2)$</span><span data-line="305"></span> の2つの fib 関数の呼び出しを表現しています。したがって、この関手の不動点 <span data-line="305"></span><span class="math-inline">$\mu F_{fib}$</span><span data-line="305"></span> は、fib の call tree (二分木) を表す再帰的データ構造になります。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="307" data-line-first="308" ><code data-line="308"><span class='token comment haskell'>{-</span><span class='token comment haskell'> fibのcall</span><span class='token comment haskell'>-</span><span class='token comment haskell'>treeを構築する関手 </span><span class='token comment haskell'>-}</span><br><span class='token keyword haskell'>data</span> <span class='token type identifier haskell'>FibT</span> <span class='token type identifier typevar haskell'>a</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>FZero</span> <span class='token keyword operator haskell'>|</span> <span class='token constructor haskell'>FOne</span> <span class='token keyword operator haskell'>|</span> <span class='token constructor haskell'>FNode</span> <span class='token type identifier typevar haskell'>a</span> <span class='token type identifier typevar haskell'>a</span><br><span class='token comment haskell'>{-</span><span class='token comment haskell'> FibTは関手のインスタンスである </span><span class='token comment haskell'>-}</span><br><span class='token keyword haskell'>instance</span> <span class='token type identifier haskell'>Functor</span> <span class='token type identifier haskell'>FibT</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>fmap</span> <span class='token identifier wildcard haskell'>_</span> <span class='token constructor haskell'>FZero</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>FZero</span><br>  <span class='token identifier haskell'>fmap</span> <span class='token identifier wildcard haskell'>_</span> <span class='token constructor haskell'>FOne</span>  <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>FOne</span> <br>  <span class='token identifier haskell'>fmap</span> <span class='token identifier haskell'>f</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>FNode</span> <span class='token identifier haskell'>a</span> <span class='token identifier haskell'>b</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>FNode</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>f</span> <span class='token identifier haskell'>b</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br><br><span class='token identifier haskell'>fibAsHylo</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>Int</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>Int</span><br><span class='token identifier haskell'>fibAsHylo</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>hylo</span> <span class='token identifier haskell'>phi</span> <span class='token identifier haskell'>psi</span> <span class='token keyword haskell'>where</span><br>  <span class='token comment haskell'>{-</span><span class='token comment haskell'> fibのcall</span><span class='token comment haskell'>-</span><span class='token comment haskell'>treeを構成する </span><span class='token comment haskell'>-}</span><br>  <span class='token identifier haskell'>psi</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>Int</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>FibT</span> <span class='token type identifier haskell'>Int</span><br>  <span class='token identifier haskell'>psi</span> <span class='token number haskell'>0</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>FZero</span> <span class='token comment haskell'>-- f(0) [葉]</span><br>  <span class='token identifier haskell'>psi</span> <span class='token number haskell'>1</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>FOne</span>  <span class='token comment haskell'>-- f(1) [葉]</span><br>  <span class='token identifier haskell'>psi</span> <span class='token identifier haskell'>n</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>FNode</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span> <span class='token operator haskell'>-</span> <span class='token number haskell'>1</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span> <span class='token operator haskell'>-</span> <span class='token number haskell'>2</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token comment haskell'>-- f(n-1), f(n-2) を子にする枝</span><br><br>  <span class='token comment haskell'>{-</span><span class='token comment haskell'> 作られた call</span><span class='token comment haskell'>-</span><span class='token comment haskell'>tree を評価する </span><span class='token comment haskell'>-}</span><br>  <span class='token identifier haskell'>phi</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>FibT</span> <span class='token type identifier haskell'>Int</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>Int</span><br>  <span class='token identifier haskell'>phi</span> <span class='token constructor haskell'>FZero</span> <span class='token keyword operator haskell'>=</span> <span class='token number haskell'>0</span> <span class='token comment haskell'>-- f(0) = 0</span><br>  <span class='token identifier haskell'>phi</span> <span class='token constructor haskell'>FOne</span> <span class='token keyword operator haskell'>=</span> <span class='token number haskell'>1</span> <span class='token comment haskell'>-- f(1) = 1</span><br>  <span class='token identifier haskell'>phi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>FNode</span> <span class='token identifier haskell'>a</span> <span class='token identifier haskell'>b</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>a</span> <span class='token operator haskell'>+</span> <span class='token identifier haskell'>b</span> <span class='token comment haskell'>-- f(n - 1) + f(n - 2)</span><br><br><span class='token comment haskell'>{-</span><br><span class='token comment haskell'>main = print $ fibAsHylo 10</span><br><span class='token comment haskell'>結果: 55</span><br><span class='token comment haskell'>-}</span></code></pre>
<p class="p indent para-continued" data-line="336"><span data-line="336"></span>これで再帰関数をhyloで表せることが分かりました。しかしこの場合、引数の値が大きくなるにつれ、ana によって作られる中間データ構造の大きさが指数的に増えていきます。これは一般に再帰関数のcall-treeが指数的に大きくなるのと同じ現象です。
</p>
<p class="p indent" data-line="338"><span data-line="338"></span>普通、再帰関数が指数的に増えないようにするためには、<span data-line="338"></span><a href="https://ja.wikipedia.org/wiki/メモ化">メモ化</a><span data-line="338"></span>などの技法が考えられます。そして、hyloについても同様にメモ化を考えることができ、それがずばり<span data-line="338"></span><em class="em-star1" >dynamorphism</em><span data-line="338"></span>なのですが、dynamorphism を導入する前にまず histomorphism について解説します。
</p><h2 id="sec-histomorphism" class="h1"    data-line="340"  style="display:block;bookmark:5.&#8194;histomorphism;level:1"><span data-line="340"></span><span class="heading-before"><span class="heading-label">5</span>.&#8194;</span><span data-line="340"></span>histomorphism</h2>
<p class="p indent" data-line="342"><span data-line="342"></span>histmorphism は catamorphism の拡張であり、catamorphismは直前の結果しか参照できなかったものを、過去の任意の時点での結果を参照できるようにしたものです。
これを実現するためには、過去の値を保持できるようなデータ構造を作らなければなりません。以下ではまず与えられた関手Fに対してそのようなデータ構造を構成する方法を示し、その上で histmorphism を定義します。
</p><h3 id="sec-ftimes_a-tildef" class="h2"    data-line="345"  style="display:block;bookmark:5.1.&#8194;$F^{\5C times}_A$ \3068  $\5C tilde{F}$;level:2"><span data-line="345"></span><span class="heading-before"><span class="heading-label">5.1</span>.&#8194;</span><span data-line="345"></span><span class="math-inline">$F^{\times}_A$</span><span data-line="345"></span> と <span data-line="345"></span><span class="math-inline">$\tilde{F}$</span></h3>
<p class="p indent para-continue" data-line="347"><span data-line="347"></span>関手 <span data-line="347"></span><span class="math-inline">$F$</span><span data-line="347"></span> と 型 <span data-line="347"></span><span class="math-inline">$A$</span><span data-line="347"></span> について、 <span data-line="347"></span><span class="math-inline">$F^{\times}_A$</span><span data-line="347"></span> を以下の様に定義します。
</p>
<div class="equation para-block"  data-line="349" style="line-adjust:0"><span data-line="349"></span><span class="equation-before" ><span class="equation-label">(9)</span></span><span data-line="349"></span>

<div class="mathdisplay para-block input-math"   data-line="350" style="line-adjust:0"><span class="mathdisplay math-display"  >\[F^{\times}_A(X) = A \times F(X) \\
F^{\times}_A(f) = id_A \times F(f)
\]</span></div></div>
<p class="p indent para-continued" data-line="354"><span data-line="354"></span><span class="math-inline">$F^{\times}_A(X)$</span><span data-line="354"></span> は、F(X) に 型 A の情報(タグ)を付加したものとみなすことが出来ます。
</p>
<p class="p indent para-continue" data-line="356"><span data-line="356"></span>さらに、<span data-line="356"></span><span class="math-inline">$F^{\times}_A(X)$</span><span data-line="356"></span>を用いて、<span data-line="356"></span><span class="math-inline">${\tilde F}(X)$</span><span data-line="356"></span> を以下のように定義します。
</p>
<div class="equation para-block"  data-line="358" style="line-adjust:0"><span data-line="358"></span><span class="equation-before" ><span class="equation-label">(10)</span></span><span data-line="358"></span>

<div class="mathdisplay para-block input-math"   data-line="359" style="line-adjust:0"><span class="mathdisplay math-display"  >\[{\tilde F}(A) = \mu F^{\times}_A \\
{\tilde F}(f) = {\sf ana}(\langle f \circ \epsilon, \theta \rangle)_{F^{\times}_A}
\]</span></div></div>
<p class="p indent para-continued" data-line="363"><span data-line="363"></span><span class="math-inline">$ ana(-)_{F^{\times}_A} $</span><span data-line="363"></span> は <span data-line="363"></span><span class="math-inline">$ { F^{\times}_A } $</span><span data-line="363"></span> <span data-line="363"></span>-余代数における anamorphism です。 <span data-line="363"></span><span class="math-inline">$\epsilon, \theta$</span><span data-line="363"></span> は後に述べます。
</p>
<p class="p indent" data-line="365"><span data-line="365"></span>さて、<span data-line="365"></span><span class="math-inline">${\tilde F}(A)$</span><span data-line="365"></span> はどういう意味なのでしょうか。 原論文(参考文献<span data-line="365"></span>[1]<span data-line="365"></span>)にはこうあります。
</p>
<blockquote  data-line="367">

<p class="p indent" data-line="367"><span data-line="367"></span><span class="math-inline">${\tilde F}(A)$</span><span data-line="367"></span> a datatype of <span data-line="367"></span><span class="math-inline">$F$</span><span data-line="367"></span>-branching trees, where every node is annotated by values of type A. 
</p></blockquote>
<p class="p indent" data-line="369"><span data-line="369"></span>つまり、例えば 関手<span data-line="369"></span><span class="math-inline">$F(X)$</span><span data-line="369"></span> が木を構成するならば、<span data-line="369"></span><span class="math-inline">${\tilde F}(A)$</span><span data-line="369"></span>は木の全てのノードに型 A の値が付加されたデータ構造になります。
次の章に登場する histomorphism では、このAの部分に途中の計算結果を格納することによって、その結果を後から再利用することを可能にしています。
以下、<span data-line="371"></span><span class="math-inline">${\tilde F}(A)$</span><span data-line="371"></span>が表すデータ構造を<span data-line="371"></span><em class="em-star1" ><span class="math-inline">${\tilde F}$</span>-tree</em><span data-line="371"></span>と表現します。
</p>
<p class="p indent" data-line="373"><span data-line="373"></span>特に <span data-line="373"></span><span class="math-inline">$A = 1$</span><span data-line="373"></span> である場合、つまり付加する情報がない場合 <span data-line="373"></span><span class="math-inline">${\tilde F}(1) = \mu F$</span><span data-line="373"></span> となり <span data-line="373"></span><span class="math-inline">$F(X)$</span><span data-line="373"></span> によって構成されるデータ構造と同型になります。
</p>
<p class="p indent" data-line="375"><span data-line="375"></span>ここで<span data-line="375"></span><span class="math-inline">${\tilde F}$</span><span data-line="375"></span>についての関数 <span data-line="375"></span><span class="math-inline">$\epsilon, \theta$</span><span data-line="375"></span> が登場します。<span data-line="375"></span><span class="math-inline">$\epsilon$</span><span data-line="375"></span>は <span data-line="375"></span><span class="math-inline">${\tilde F}(A)$</span><span data-line="375"></span> を受け取り、付加された型<span data-line="375"></span><span class="math-inline">$A$</span><span data-line="375"></span>の値 を取り出す関数です。後のコードでは <span data-line="375"></span><code class="code code1" >extract</code><span data-line="375"></span> という名前で定義します。
また、<span data-line="376"></span><span class="math-inline">$\theta$</span><span data-line="376"></span> は、<span data-line="376"></span><span class="math-inline">${\tilde F}(A)$</span><span data-line="376"></span> を受け取り、<span data-line="376"></span><span class="math-inline">$F({\tilde F}(A))$</span><span data-line="376"></span>を返します。これは元の(F(X)によって構成された)木構造を取り出す関数です。後のコードでは <span data-line="376"></span><code class="code code1" >sub</code><span data-line="376"></span> という名前です。
</p>
<div class="note"  data-line="378" style="display:block">
<p class="p indent" data-line="379"><span data-line="379"></span><span class="note-before"><strong class="strong-star2" ><span class="note-caption">Note</span></strong>.
</span><span data-line="380"></span><span class="math-inline">$ {\tilde F}(f) $</span><span data-line="380"></span> はどのようなマッピングなのでしょうか。<span data-line="380"></span><span class="math-inline">$f$</span><span data-line="380"></span> が <span data-line="380"></span><span class="math-inline">$A \to B$</span><span data-line="380"></span> であることを考えると、これは各ノードに付加された型Aの値全てにfを適用する意味であることが推測されます。実際 ana によって、<span data-line="380"></span><span class="math-inline">${\tilde F}(A)$</span><span data-line="380"></span> から、<span data-line="380"></span><span class="math-inline">${\tilde F}(B)$</span><span data-line="380"></span> の木構造が<span data-line="380"></span><em class="em-star1" >再構築</em><span data-line="380"></span>されます。</p></div>
<p class="p indent" data-line="382"><span data-line="382"></span>実際のHaskellでの実装は以下のようになります。なお、<span data-line="382"></span><span class="math-inline">$F^{\times}_A(X)$</span><span data-line="382"></span>は <span data-line="382"></span><code class="code code1" >Fx</code><span data-line="382"></span>、<span data-line="382"></span><span class="math-inline">${\tilde F}(X)$</span><span data-line="382"></span>のことを <span data-line="382"></span><strong class="strong-star2" >Cofree</strong><span data-line="382"></span> という名前にしています。<span data-line="382"></span><sup id="back-fn-cofree" ><a href="#fn-cofree" title="12.Cofree という名前は、Cofree Comonad から来ています。実際この${\tilde F}(X)$はComonadになります。圏${\mathcal CoAlg}(F)$から$Hask$への忘却関手 $U_F (A, a) = A$ は、${\sf Cofree}_F A = (\tilde F(A), \theta)$ という右随伴を持ち、それらの随伴対から comonad ${\tilde F} = {\sf U}_F \circ {\sf Cofree}_F$ が導かれます。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">12</span></a></sup><span data-line="382"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="384" data-line-first="385" ><code data-line="385"><span class='token comment haskell'>-- Fx = A × F(X)</span><br><span class='token keyword haskell'>data</span> <span class='token type identifier haskell'>Fx</span> <span class='token type identifier typevar haskell'>f</span> <span class='token type identifier typevar haskell'>a</span> <span class='token type identifier typevar haskell'>x</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>FCons</span> <span class='token type identifier typevar haskell'>a</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier typevar haskell'>f</span> <span class='token type identifier typevar haskell'>x</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span><br><span class='token keyword haskell'>instance</span> <span class='token type identifier haskell'>Functor</span> <span class='token type identifier typevar haskell'>f</span> <span class='token keyword haskell'>=</span><span class='token operator haskell'>&gt;</span> <span class='token constructor haskell'>Functor</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Fx</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>fmap</span> <span class='token identifier haskell'>f</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>FCons</span> <span class='token identifier haskell'>x</span> <span class='token identifier haskell'>xs</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>FCons</span> <span class='token identifier haskell'>x</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>fmap</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>xs</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br><br><span class='token comment haskell'>-- Cofree の宣言</span><br><span class='token keyword haskell'>newtype</span> <span class='token constructor haskell'>Cofree</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>Cf</span> <span class='token delimiter curly haskell bracket-open'>{</span> <span class='token identifier haskell'>unCf</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>FixF</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier haskell'>Fx</span> <span class='token type identifier typevar haskell'>f</span> <span class='token type identifier typevar haskell'>a</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span> <span class='token delimiter curly haskell bracket-close'>}</span><br><br><span class='token comment haskell'>-- Cofree が関手に成るための宣言</span><br><span class='token keyword haskell'>instance</span> <span class='token type identifier haskell'>Functor</span> <span class='token type identifier typevar haskell'>f</span> <span class='token keyword haskell'>=</span><span class='token operator haskell'>&gt;</span> <span class='token constructor haskell'>Functor</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Cofree</span> <span class='token identifier haskell'>f</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>fmap</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>Cf</span> <span class='token operator haskell'>.</span> <span class='token identifier haskell'>ana</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>phi</span> <span class='token operator haskell'>.</span> <span class='token identifier haskell'>outF</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token operator haskell'>.</span> <span class='token identifier haskell'>unCf</span> <span class='token keyword haskell'>where</span><br>    <span class='token identifier haskell'>phi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>FCons</span> <span class='token identifier haskell'>a</span> <span class='token identifier haskell'>b</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>FCons</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token identifier haskell'>b</span><br><br><span class='token comment haskell'>-- ノードの付加情報を取り出す</span><br><span class='token identifier haskell'>extract</span> <span class='token type operator haskell'>::</span> <span class='token constructor haskell'>Functor</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>=&gt;</span> <span class='token constructor haskell'>Cofree</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>a</span><br><span class='token identifier haskell'>extract</span> <span class='token identifier haskell'>cf</span> <span class='token keyword operator haskell'>=</span> <span class='token keyword haskell'>case</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>outF</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>unCf</span> <span class='token identifier haskell'>cf</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword haskell'>of</span><br>  <span class='token constructor haskell'>FCons</span> <span class='token identifier haskell'>a</span> <span class='token identifier wildcard haskell'>_</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>a</span><br><br><span class='token comment haskell'>-- ノードを取り出す</span><br><span class='token identifier haskell'>sub</span> <span class='token type operator haskell'>::</span> <span class='token constructor haskell'>Functor</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>=&gt;</span> <span class='token constructor haskell'>Cofree</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>f</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Cofree</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br><span class='token identifier haskell'>sub</span> <span class='token identifier haskell'>cf</span> <span class='token keyword operator haskell'>=</span> <span class='token keyword haskell'>case</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>outF</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>unCf</span> <span class='token identifier haskell'>cf</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword haskell'>of</span><br>  <span class='token constructor haskell'>FCons</span> <span class='token identifier wildcard haskell'>_</span> <span class='token identifier haskell'>b</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>fmap</span> <span class='token constructor haskell'>Cf</span> <span class='token identifier haskell'>b</span></code></pre><h3 id="sec-histomorphism" class="h2"    data-line="409"  style="display:block;bookmark:5.2.&#8194;histomorphism;level:2"><span data-line="409"></span><span class="heading-before"><span class="heading-label">5.2</span>.&#8194;</span><span data-line="409"></span>histomorphism</h3>
<p class="p indent" data-line="411"><span data-line="411"></span>前述したように、関手<span data-line="411"></span><span class="math-inline">$F$</span><span data-line="411"></span>に対する<span data-line="411"></span><span class="math-inline">${\tilde F}$</span><span data-line="411"></span>とは、Fによる再帰的データ構造のそれぞれのノードに値を付加できるようにしたものです。そこへ結果を格納することによって、後の任意の時点でその計算結果を参照することが可能になります。以下、histmorphismの定義からはじめます。
</p>
<p class="p indent para-continue" data-line="413"><span data-line="413"></span><span class="math-inline">$F{\tilde F}$</span><span data-line="413"></span>-代数 <span data-line="413"></span><span class="math-inline">$(F{\tilde F}A, \varphi : F{\tilde F}A \to A)$</span><span data-line="413"></span> に対して、<span data-line="413"></span><strong class="strong-star2" >histomorphism</strong><span data-line="413"></span> は以下の図式を可換にするような一意な関数 <span data-line="413"></span><span class="math-inline">${\sf histo}(\varphi)$</span><span data-line="413"></span> のことを言います。
</p>
<div id="hist1" class="equation para-block"  data-line="415" style="line-adjust:0"><span data-line="415"></span><span class="equation-before" ><span class="equation-label">(11)</span></span><span data-line="415"></span>

<div class="mathdisplay para-block input-math"   data-line="416" style="line-adjust:0"><span class="mathdisplay math-display"  >\[{\sf histo}(\varphi) = \varphi \circ F ( {\sf ana} \langle {\sf histo}(\varphi), {\sf outF} \rangle ) \circ {\sf outF}
\]</span></div></div>
<div class="center align-center" data-line="419" style="text-align:center">
<p class="p indent" data-line="420"><span data-line="420"></span><img src="diagrams/fig7.png" alt="fig-histo1" data-path="diagrams/fig7.png" data-linkid="fig-histo1" style="height:150px"></p></div>
<p class="p indent" data-line="422"><span data-line="422"></span>histmorphism は、<span data-line="422"></span><span class="math-inline">${\tilde F}$</span><span data-line="422"></span> <span data-line="422"></span>-tree に対する catamorphism であると喩えることができます。
</p>
<p class="p indent" data-line="424"><span data-line="424"></span>先程のhistoの定義をHaskellで実装すると以下のようになります。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="425" data-line-first="426" ><code data-line="426"><span class='token identifier haskell'>histo</span> <span class='token type operator haskell'>::</span> <span class='token constructor haskell'>Functor</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>=&gt;</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>f</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Cofree</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token constructor haskell'>FixF</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>a</span><br><span class='token identifier haskell'>histo</span> <span class='token identifier haskell'>phi</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>phi</span> <span class='token operator haskell'>.</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>fmap</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Cf</span> <span class='token operator haskell'>.</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>ana</span> <span class='token identifier haskell'>proj</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token operator haskell'>.</span> <span class='token identifier haskell'>outF</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>proj</span> <span class='token identifier haskell'>a</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>FCons</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>histo</span> <span class='token identifier haskell'>phi</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>outF</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span></code></pre>
<p class="p indent para-continued para-continue" data-line="431"><span data-line="431"></span>また、histoの表現は他にもあります。<span data-line="431"></span><sup id="back-fn-histo2" ><a href="#fn-histo2" title="13.原論文(参考文献[1])によればこの定義のほうが more efficient らしいです。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">13</span></a></sup><span data-line="431"></span>
</p>
<div id="hist2" class="equation para-block"  data-line="433" style="line-adjust:0"><span data-line="433"></span><span class="equation-before" ><span class="equation-label">(12)</span></span><span data-line="433"></span>

<div class="mathdisplay para-block input-math"   data-line="434" style="line-adjust:0"><span class="mathdisplay math-display"  >\[{\sf histo}(\varphi) = \epsilon \circ {\sf cata} ( {\sf inF} \circ \langle \varphi, {\sf id} \rangle )
\]</span></div></div>
<p class="p indent para-continued" data-line="437"><span data-line="437"></span><a href="#hist2" class="localref" style="target-element:equation"><span class="equation-label">(12)</span></a><span data-line="437"></span> がどう導かれるかは以下の図式を辿ってみれば分かると思います。
</p>
<div class="center align-center" data-line="439" style="text-align:center">
<p class="p indent" data-line="440"><span data-line="440"></span><img src="diagrams/fig8.png" alt="fig-histo2" data-path="diagrams/fig8.png" data-linkid="fig-histo2" style="height:150px"></p></div>
<p class="p indent" data-line="443"><span data-line="443"></span><a href="#hist2" class="localref" style="target-element:equation"><span class="equation-label">(12)</span></a><span data-line="443"></span> をHaskellで実装すると以下のようになります。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="445" data-line-first="446" ><code data-line="446"><span class='token identifier haskell'>histo&apos;</span> <span class='token type operator haskell'>::</span> <span class='token constructor haskell'>Functor</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>=&gt;</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>f</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Cofree</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token constructor haskell'>FixF</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>a</span><br><span class='token identifier haskell'>histo&apos;</span> <span class='token identifier haskell'>phi</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>extract</span> <span class='token operator haskell'>.</span> <span class='token identifier haskell'>cata</span> <span class='token identifier haskell'>ap</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>ap</span> <span class='token identifier haskell'>a</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>Cf</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>InF</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>FCons</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>phi</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>fmap</span> <span class='token identifier haskell'>unCf</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span></code></pre>
<p class="p indent para-continued" data-line="451"><span data-line="451"></span>さて、histomorphism を用いた例を見てみましょう。ここでは再度フィボナッチ数列のn番目を返す関数 <span data-line="451"></span><span class="math-inline">$fib(n)$</span><span data-line="451"></span> を考えます。histomorphism は、引数としてデータ構造を取るため、別途引数として渡すためのデータ構造を作っておく必要があります。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="453" data-line-first="454" ><code data-line="454"><span class='token comment haskell'>-- 関手 TNat(X) = 1 + X、整数を構成する</span><br><span class='token keyword haskell'>data</span> <span class='token type identifier haskell'>TNat</span> <span class='token type identifier typevar haskell'>a</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>Zero</span> <span class='token keyword operator haskell'>|</span> <span class='token constructor haskell'>Succ</span> <span class='token type identifier typevar haskell'>a</span><br><span class='token keyword haskell'>instance</span> <span class='token type identifier haskell'>Functor</span> <span class='token type identifier haskell'>TNat</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>fmap</span> <span class='token identifier haskell'>f</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Succ</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>Succ</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>a</span><br>  <span class='token identifier haskell'>fmap</span> <span class='token identifier wildcard haskell'>_</span> <span class='token constructor haskell'>Zero</span>     <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>Zero</span><br><br><span class='token comment haskell'>-- 正の整数を表現するデータ型 Nat = μTNat</span><br><span class='token keyword haskell'>type</span> <span class='token type identifier haskell'>Nat</span> <span class='token keyword haskell'>=</span> <span class='token type identifier haskell'>FixF</span> <span class='token type identifier haskell'>TNat</span><br><br><span class='token comment haskell'>-- 整数型からNatへ変換する関数</span><br><span class='token identifier haskell'>nat</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>Integer</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>Nat</span><br><span class='token identifier haskell'>nat</span> <span class='token number haskell'>0</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>InF</span> <span class='token constructor haskell'>Zero</span><br><span class='token identifier haskell'>nat</span> <span class='token identifier haskell'>n</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>InF</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>Succ</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>nat</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>n</span> <span class='token operator haskell'>-</span> <span class='token number haskell'>1</span><br><br><span class='token comment haskell'>-- フィボナッチ数列を求める</span><br><span class='token identifier haskell'>fibAsHisto</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>Nat</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>Integer</span><br><span class='token identifier haskell'>fibAsHisto</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>histo&apos;</span> <span class='token identifier haskell'>phi</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>phi</span> <span class='token constructor haskell'>Zero</span> <span class='token keyword operator haskell'>=</span> <span class='token number haskell'>0</span> <span class='token comment haskell'>-- (a)</span><br>  <span class='token identifier haskell'>phi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Succ</span> <span class='token identifier haskell'>x</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>f1</span> <span class='token operator haskell'>+</span> <span class='token identifier haskell'>f2</span> <span class='token keyword haskell'>where</span> <span class='token comment haskell'>-- (b)</span><br>    <span class='token identifier haskell'>f1</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>extract</span> <span class='token identifier haskell'>x</span><br>    <span class='token identifier haskell'>f2</span> <span class='token keyword operator haskell'>=</span> <span class='token keyword haskell'>case</span> <span class='token identifier haskell'>sub</span> <span class='token identifier haskell'>x</span> <span class='token keyword haskell'>of</span><br>      <span class='token constructor haskell'>Zero</span>   <span class='token keyword operator haskell'>-&gt;</span> <span class='token number haskell'>1</span> <span class='token comment haskell'>-- (c1)</span><br>      <span class='token constructor haskell'>Succ</span> <span class='token identifier haskell'>y</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>extract</span> <span class='token identifier haskell'>y</span> <span class='token comment haskell'>-- (c2)</span><br><br><span class='token identifier haskell'>main</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>print</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>fibAsHisto</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>nat</span> <span class='token number haskell'>100</span></code></pre>
<p class="p indent para-continued" data-line="481"><span data-line="481"></span><code class="code code1" >fibAsHisto</code><span data-line="481"></span> の入力は、関手 <span data-line="481"></span><code class="code code1" >TNat</code><span data-line="481"></span> によって構成されるデータ構造 <span data-line="481"></span><span class="math-inline">$\mu TNat$</span><span data-line="481"></span> になります。ここで <span data-line="481"></span><span class="math-inline">$TNat(X) = 1 + X$</span><span data-line="481"></span> であり、型レベルで自然数を構成しています。
</p>
<p class="p indent" data-line="483"><span data-line="483"></span><code class="code code1" >phi</code><span data-line="483"></span> について、 <span data-line="483"></span><code class="code code1" >(a)</code><span data-line="483"></span> は 引数に 0 が来た時に 0 を返すことを表しています。引数に 1 以上が来た時は、<span data-line="483"></span><code class="code code1" >fib(i-1) + fib(i-2)</code><span data-line="483"></span> を計算します <span data-line="483"></span><code class="code code1" >(b)</code><span data-line="483"></span>。
</p>
<p class="p indent" data-line="485"><span data-line="485"></span><code class="code code1" >f1</code><span data-line="485"></span> は 現在のノードの付加情報を取り出しています。これは直前の結果が入っており、これが<span data-line="485"></span><code class="code code1" >f(i-1)</code><span data-line="485"></span>を表現しています。
また、<span data-line="486"></span><code class="code code1" >f2</code><span data-line="486"></span>では<span data-line="486"></span><span class="math-inline">${\tilde F}$</span><span data-line="486"></span>-tree の子ノード (subtree) を遡って2つ前の結果 <span data-line="486"></span><code class="code code1" >f(i-2)</code><span data-line="486"></span> を取り出しています <span data-line="486"></span><code class="code code1" >(c2)</code><span data-line="486"></span>。ただし subtree が遡れない場合は、1を返しています<span data-line="486"></span><code class="code code1" >(c1)</code><span data-line="486"></span>。これが <span data-line="486"></span><code class="code code1" >fib(1)</code><span data-line="486"></span> を表しています。
</p>
<p class="p indent" data-line="488"><span data-line="488"></span><code class="code code1" >fibAsHylo</code><span data-line="488"></span> に比べ <span data-line="488"></span><code class="code code1" >fibAsHisto</code><span data-line="488"></span> は実行速度が著しく上がっています。これは過去の結果を再利用することで、同じ計算を繰り返さずにすむようになったからです。
</p><h2 id="sec-dynamorphism" class="h1"    data-line="490"  style="display:block;bookmark:6.&#8194;dynamorphism;level:1"><span data-line="490"></span><span class="heading-before"><span class="heading-label">6</span>.&#8194;</span><span data-line="490"></span>dynamorphism</h2>
<p class="p indent" data-line="492"><span data-line="492"></span><strong class="strong-star2" >dynamorphism</strong><span data-line="492"></span> は、histomorphism の前に anamorphism をつなげたものです。つまり、anamorphism でデータ構造を構築し、histomorphism でそれを畳み込む一連の処理を行います。これは hylomorphism の考え方と同じです。よって、dynamorphism は プリミティブな型(整数や文字列など) を受け取りプリミティブな型を返す関数となり、関数を呼び出す側からは中間のデータ構造を意識する必要がなくなります。
</p>
<p class="p indent para-continue" data-line="494"><span data-line="494"></span>dynamorphism の定義は以下のようになっています。<span data-line="494"></span><sup id="back-fn-dyna" ><a href="#fn-dyna" title="14.原論文(参考文献[1])では $\varphi \circ F({\sf ana} \langle f, \psi \rangle) \circ \psi = f$ となるような $f$ を dynamorphism と定義し、そこから非自明に&nbsp;(13) を導いているのですが、都合上(訳:証明がわからない)のでこれを定義にしています。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">14</span></a></sup><span data-line="494"></span>
</p>
<div id="dynadef" class="equation para-block"  data-line="496" style="line-adjust:0"><span data-line="496"></span><span class="equation-before" ><span class="equation-label">(13)</span></span><span data-line="496"></span>

<div class="mathdisplay para-block input-math"   data-line="497" style="line-adjust:0"><span class="mathdisplay math-display"  >\[  {\sf dyna}(\varphi, \psi) = {\sf histo} (\varphi) \circ {\sf ana} (\psi)
\]</span></div></div>
<p class="p indent para-continued para-continue" data-line="500"><span data-line="500"></span>また、hylo を用いて以下のようにも表せます。
</p>
<div id="dynadef2" class="equation para-block"  data-line="502" style="line-adjust:0"><span data-line="502"></span><span class="equation-before" ><span class="equation-label">(14)</span></span><span data-line="502"></span>

<div class="mathdisplay para-block input-math"   data-line="503" style="line-adjust:0"><span class="mathdisplay math-display"  >\[  {\sf dyna}(\varphi, \psi) = \epsilon \circ {\sf hylo} ({\sf inF} \circ \langle \varphi, {\sf id} \rangle, \psi)
\]</span></div></div>
<p class="p indent para-continued" data-line="506"><span data-line="506"></span><a href="#dynadef2" class="localref" style="target-element:equation"><span class="equation-label">(14)</span></a><span data-line="506"></span> は<span data-line="506"></span>&nbsp;<a href="#hylodef" class="localref" style="target-element:equation"><span class="equation-label">(7)</span></a><span data-line="506"></span>,<span data-line="506"></span>&nbsp;<a href="#hist2" class="localref" style="target-element:equation"><span class="equation-label">(12)</span></a><span data-line="506"></span>,<span data-line="506"></span>&nbsp;<a href="#dynadef" class="localref" style="target-element:equation"><span class="equation-label">(13)</span></a><span data-line="506"></span> から自明に導かれます。
</p>
<p class="p indent" data-line="508"><span data-line="508"></span><a href="#dynadef2" class="localref" style="target-element:equation"><span class="equation-label">(14)</span></a><span data-line="508"></span> を Haskell で実装すると以下のようになります。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="510" data-line-first="511" ><code data-line="511"><span class='token identifier haskell'>dyna</span> <span class='token type operator haskell'>::</span> <span class='token constructor haskell'>Functor</span> <span class='token identifier haskell'>f</span> <span class='token keyword operator haskell'>=&gt;</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>f</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Cofree</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>x</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>x</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>y</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>f</span> <span class='token identifier haskell'>y</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>y</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>x</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br><span class='token identifier haskell'>dyna</span> <span class='token identifier haskell'>phi</span> <span class='token identifier haskell'>psi</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>extract</span> <span class='token operator haskell'>.</span> <span class='token identifier haskell'>hylo</span> <span class='token identifier haskell'>ap</span> <span class='token identifier haskell'>psi</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>ap</span> <span class='token identifier haskell'>a</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>Cf</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>InF</span> <span class='token operator haskell'>$</span> <span class='token constructor haskell'>FCons</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>phi</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>fmap</span> <span class='token identifier haskell'>unCf</span> <span class='token identifier haskell'>a</span><span class='token delimiter parenthesis haskell bracket-close'>)</span></code></pre>
<p class="p indent para-continued" data-line="516"><span data-line="516"></span>dynamorphism の例を上げます。fibについては先ほどの <span data-line="516"></span><code class="code code1" >fibAsHisto</code><span data-line="516"></span> に若干の変更を加えるだけなので簡単です。ここでは動的計画法の典型的な例である「<span data-line="516"></span><a href="http://dai1741.github.io/maximum-algo-2012/docs/dynamic-programming/">0-1ナップサック問題</a><span data-line="516"></span>」を実装してみます。
</p>
<p class="p indent" data-line="518"><span data-line="518"></span>0-1 ナップサック問題とは、
</p>
<blockquote  data-line="520">

<p class="p indent" data-line="520"><span data-line="520"></span>容量 c のナップサックが一つと、n個の品物（それぞれ 価値 v<span data-line="520"></span>[i]<span data-line="520"></span>, 容積 w<span data-line="520"></span>[i]<span data-line="520"></span>）が与えられたとき、ナップサックの容量 c を超えない範囲で価値を最大にするように品物を詰めた時、価値の総和はいくつになるか。
</p></blockquote>
<p class="p indent" data-line="522"><span data-line="522"></span>という問題です。
</p>
<p class="p indent para-continue" data-line="524"><span data-line="524"></span>この問題は動的計画法で厳密解が求まります。<span data-line="524"></span><span class="math-inline">$dp[i][j]$</span><span data-line="524"></span> を 「i番目以降の品物から容量jでの最大値となるように選んだ時の価値の和」とすると、
</p>
<div id="dp" class="equation para-block"  data-line="526" style="line-adjust:0"><span data-line="526"></span><span class="equation-before" ><span class="equation-label">(15)</span></span><span data-line="526"></span>

<div class="mathdisplay para-block input-math"   data-line="527" style="line-adjust:0"><span class="mathdisplay math-display"  >\[dp[i][j] = \begin{cases}
0 &amp; (i = n) \\
max(dp[i+1][j],\ dp[i+1][j-w[i]] + v[i]) &amp; (j \ge w[i]) \\
dp[i+1][j] &amp; ({\rm otherwise})
\end{cases}
\]</span></div></div>
<p class="p indent para-continued" data-line="534"><span data-line="534"></span>としたときの <span data-line="534"></span><span class="math-inline">$dp[0][c]$</span><span data-line="534"></span> が解となります。
</p>
<p class="p indent" data-line="536"><span data-line="536"></span>さて、これを dynamorphism で実装してみます。以下がコードです。
</p>
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="538" data-line-first="539" ><code data-line="539"><span class='token comment haskell'>-- psi によって作られる中間データ構造、(Int, Int) のフィールドを持ち、dp[i][j] のインデックス i,j を表現している。</span><br><span class='token keyword haskell'>data</span> <span class='token type identifier haskell'>KSTree</span> <span class='token type identifier typevar haskell'>a</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>KSTree</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier haskell'>Int</span><span class='token delimiter type haskell'>,</span> <span class='token type identifier haskell'>Int</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span> <span class='token delimiter parenthesis haskell type bracket-open'>(</span><span class='token type identifier haskell'>Maybe</span> <span class='token type identifier typevar haskell'>a</span><span class='token delimiter parenthesis haskell type bracket-close'>)</span><br><span class='token keyword haskell'>instance</span> <span class='token type identifier haskell'>Functor</span> <span class='token type identifier haskell'>KSTree</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>fmap</span> <span class='token identifier haskell'>f</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>KSTree</span> <span class='token identifier haskell'>a</span> <span class='token constructor haskell'>Nothing</span><span class='token delimiter parenthesis haskell bracket-close'>)</span>  <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>KSTree</span> <span class='token identifier haskell'>a</span> <span class='token constructor haskell'>Nothing</span><br>  <span class='token identifier haskell'>fmap</span> <span class='token identifier haskell'>f</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>KSTree</span> <span class='token identifier haskell'>a</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Just</span> <span class='token identifier haskell'>b</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>KSTree</span> <span class='token identifier haskell'>a</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Just</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>f</span> <span class='token identifier haskell'>b</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br><br><span class='token comment haskell'>{-</span><span class='token comment haskell'> 0</span><span class='token comment haskell'>-</span><span class='token comment haskell'>1ナップザック問題を解く。c は全重量の制約、vは品物の価値のリスト、wは重量のリスト </span><span class='token comment haskell'>-}</span><br><span class='token identifier haskell'>knapsack</span> <span class='token type operator haskell'>::</span> <span class='token type identifier haskell'>Int</span> <span class='token type operator haskell'>-&gt;</span> <span class='token delimiter square haskell type bracket-open'>[</span><span class='token type identifier haskell'>Int</span><span class='token delimiter square haskell type bracket-close'>]</span> <span class='token type operator haskell'>-&gt;</span> <span class='token delimiter square haskell type bracket-open'>[</span><span class='token type identifier haskell'>Int</span><span class='token delimiter square haskell type bracket-close'>]</span> <span class='token type operator haskell'>-&gt;</span> <span class='token type identifier haskell'>Int</span><br><span class='token identifier haskell'>knapsack</span> <span class='token identifier haskell'>c</span> <span class='token identifier haskell'>v</span> <span class='token identifier haskell'>w</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>dyna</span> <span class='token identifier haskell'>phi</span> <span class='token identifier haskell'>psi</span> <span class='token operator haskell'>$</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span><span class='token delimiter haskell'>,</span><span class='token identifier haskell'>c</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword haskell'>where</span><br>  <span class='token identifier haskell'>n</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>length</span> <span class='token identifier haskell'>w</span> <span class='token comment haskell'>-- 品物の数</span><br><br>  <span class='token identifier haskell'>psi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token number haskell'>0</span><span class='token delimiter haskell'>,</span><span class='token number haskell'>0</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>KSTree</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span><span class='token delimiter haskell'>,</span><span class='token number haskell'>0</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token constructor haskell'>Nothing</span><br>  <span class='token identifier haskell'>psi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token number haskell'>0</span><span class='token delimiter haskell'>,</span><span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>KSTree</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span><span class='token delimiter haskell'>,</span><span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Just</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span><span class='token delimiter haskell'>,</span> <span class='token identifier haskell'>j</span><span class='token operator haskell'>-</span><span class='token number haskell'>1</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br>  <span class='token identifier haskell'>psi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>i</span><span class='token delimiter haskell'>,</span><span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>KSTree</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span><span class='token operator haskell'>-</span><span class='token identifier haskell'>i</span><span class='token delimiter haskell'>,</span><span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Just</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>i</span><span class='token operator haskell'>-</span><span class='token number haskell'>1</span><span class='token delimiter haskell'>,</span> <span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br><br>  <span class='token identifier haskell'>phi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>KSTree</span> <span class='token identifier wildcard haskell'>_</span> <span class='token constructor haskell'>Nothing</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token number haskell'>0</span><br>  <span class='token identifier haskell'>phi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>KSTree</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>i</span><span class='token delimiter haskell'>,</span><span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Just</span> <span class='token identifier haskell'>cs</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br>    <span class='token keyword operator haskell'>|</span> <span class='token identifier haskell'>i</span> <span class='token operator haskell'>==</span> <span class='token identifier haskell'>n</span>      <span class='token keyword operator haskell'>=</span> <span class='token number haskell'>0</span><br>    <span class='token keyword operator haskell'>|</span> <span class='token identifier haskell'>w</span> <span class='token operator haskell'>!!</span> <span class='token identifier haskell'>i</span> <span class='token operator haskell'>&lt;=</span> <span class='token identifier haskell'>j</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>max</span> <span class='token identifier haskell'>x1</span> <span class='token identifier haskell'>x2</span><br>    <span class='token keyword operator haskell'>|</span> <span class='token identifier haskell'>otherwise</span>   <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>x1</span><br>    <span class='token keyword haskell'>where</span><br>      <span class='token identifier haskell'>x1</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>back</span> <span class='token number haskell'>1</span> <span class='token identifier haskell'>cs</span><br>      <span class='token identifier haskell'>x2</span> <span class='token keyword operator haskell'>=</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>v</span> <span class='token operator haskell'>!!</span> <span class='token identifier haskell'>i</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token operator haskell'>+</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>back</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token number haskell'>1</span> <span class='token operator haskell'>+</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span> <span class='token operator haskell'>+</span> <span class='token number haskell'>1</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token operator haskell'>*</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>w</span> <span class='token operator haskell'>!!</span> <span class='token identifier haskell'>i</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token identifier haskell'>cs</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br><br>  <span class='token comment haskell'>{-</span><span class='token comment haskell'> 過去の結果を遡って参照するための関数 </span><span class='token comment haskell'>-}</span><br>  <span class='token identifier haskell'>back</span> <span class='token number haskell'>1</span> <span class='token identifier haskell'>cs</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>extract</span> <span class='token identifier haskell'>cs</span><br>  <span class='token identifier haskell'>back</span> <span class='token identifier haskell'>i</span> <span class='token identifier haskell'>cs</span> <span class='token keyword operator haskell'>=</span> <span class='token keyword haskell'>case</span> <span class='token identifier haskell'>sub</span> <span class='token identifier haskell'>cs</span> <span class='token keyword haskell'>of</span><br>    <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>KSTree</span> <span class='token identifier wildcard haskell'>_</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Just</span> <span class='token identifier haskell'>b</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>back</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>i</span> <span class='token operator haskell'>-</span> <span class='token number haskell'>1</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token identifier haskell'>b</span><br><br><span class='token identifier haskell'>main</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>show</span> <span class='token operator haskell'>$</span> <span class='token identifier haskell'>knapsack</span> <span class='token number haskell'>5</span> <span class='token delimiter square haskell bracket-open'>[</span><span class='token number haskell'>4</span><span class='token delimiter haskell'>,</span><span class='token number haskell'>2</span><span class='token delimiter haskell'>,</span><span class='token number haskell'>5</span><span class='token delimiter haskell'>,</span><span class='token number haskell'>8</span><span class='token delimiter square haskell bracket-close'>]</span> <span class='token delimiter square haskell bracket-open'>[</span><span class='token number haskell'>2</span><span class='token delimiter haskell'>,</span><span class='token number haskell'>2</span><span class='token delimiter haskell'>,</span><span class='token number haskell'>1</span><span class='token delimiter haskell'>,</span><span class='token number haskell'>3</span><span class='token delimiter square haskell bracket-close'>]</span> <span class='token comment haskell'>-- 13</span></code></pre>
<p class="p indent para-continued" data-line="571"><span data-line="571"></span>さて、順番に見ていきましょう。
</p>
<div class="framed" data-line="573" style="border:solid black 1px">
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="574" data-line-first="575" ><code data-line="575">  <span class='token identifier haskell'>psi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token number haskell'>0</span><span class='token delimiter haskell'>,</span><span class='token number haskell'>0</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>KSTree</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span><span class='token delimiter haskell'>,</span><span class='token number haskell'>0</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token constructor haskell'>Nothing</span><br>  <span class='token identifier haskell'>psi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token number haskell'>0</span><span class='token delimiter haskell'>,</span><span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>KSTree</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span><span class='token delimiter haskell'>,</span><span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Just</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span><span class='token delimiter haskell'>,</span> <span class='token identifier haskell'>j</span><span class='token operator haskell'>-</span><span class='token number haskell'>1</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br>  <span class='token identifier haskell'>psi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>i</span><span class='token delimiter haskell'>,</span><span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token constructor haskell'>KSTree</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span><span class='token operator haskell'>-</span><span class='token identifier haskell'>i</span><span class='token delimiter haskell'>,</span><span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Just</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>i</span><span class='token operator haskell'>-</span><span class='token number haskell'>1</span><span class='token delimiter haskell'>,</span> <span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span></code></pre></div>
<p class="p indent" data-line="581"><span data-line="581"></span>psi 関数をanaに渡すことで中間データ構造を生成します。サンプル入力の場合、以下のようなリスト(型は<span data-line="581"></span><code class="code code1" >FixF KSTree</code><span data-line="581"></span>)を出力します。
これは <span data-line="582"></span><span class="math-inline">$dp[i][j]$</span><span data-line="582"></span> の全てのインデックスを列挙したものになっています。
</p>
<pre id="dozenlist" class="para-block pre-fenced pre-fenced3"  data-line="584" data-line-first="585"><code data-line="585">(0,5),(1,5),(2,5),(3,5),(4,5),
(0,4),(1,4),(2,4),(3,4),(4,4),
(0,3),(1,3),(2,3),(3,3),(4,3),
(0,2),(1,2),(2,2),(3,2),(4,2),
(0,1),(1,1),(2,1),(3,1),(4,1),
(0,0),(1,0),(2,0),(3,0),(4,0)</code></pre>
<p class="p indent para-continued" data-line="593"><span data-line="593"></span>これを<span data-line="593"></span><em class="em-star1" >一分木</em><span data-line="593"></span>とみなすと、ルートノードは<span data-line="593"></span><code class="code code1" >(0,5)</code><span data-line="593"></span>で終端の葉は<span data-line="593"></span><code class="code code1" >(4,0)</code><span data-line="593"></span>であり、各々のノードに対し子ノードはリストの次の要素になります。
この後の<span data-line="594"></span><code class="code code1" >histo(phi)</code><span data-line="594"></span>によりこのデータ構造が畳み込まれます。
</p>
<p class="p indent" data-line="596"><span data-line="596"></span>次に畳み込む部分を見てみます。
</p>
<div class="framed" data-line="598" style="border:solid black 1px">
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="599" data-line-first="600" ><code data-line="600">  <span class='token identifier haskell'>phi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>KSTree</span> <span class='token identifier wildcard haskell'>_</span> <span class='token constructor haskell'>Nothing</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>=</span> <span class='token number haskell'>0</span> <span class='token comment haskell'>-- (a)</span><br>  <span class='token identifier haskell'>phi</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>KSTree</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>i</span><span class='token delimiter haskell'>,</span><span class='token identifier haskell'>j</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Just</span> <span class='token identifier haskell'>cs</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><br>    <span class='token keyword operator haskell'>|</span> <span class='token identifier haskell'>i</span> <span class='token operator haskell'>==</span> <span class='token identifier haskell'>n</span>      <span class='token keyword operator haskell'>=</span> <span class='token number haskell'>0</span> <span class='token comment haskell'>-- (b)</span><br>    <span class='token keyword operator haskell'>|</span> <span class='token identifier haskell'>w</span> <span class='token operator haskell'>!!</span> <span class='token identifier haskell'>i</span> <span class='token operator haskell'>&lt;=</span> <span class='token identifier haskell'>j</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>max</span> <span class='token identifier haskell'>x1</span> <span class='token identifier haskell'>x2</span> <span class='token comment haskell'>-- (c)</span><br>    <span class='token keyword operator haskell'>|</span> <span class='token identifier haskell'>otherwise</span>   <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>x1</span> <span class='token comment haskell'>-- (d)</span><br>    <span class='token keyword haskell'>where</span><br>      <span class='token identifier haskell'>x1</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>back</span> <span class='token number haskell'>1</span> <span class='token identifier haskell'>cs</span><br>      <span class='token identifier haskell'>x2</span> <span class='token keyword operator haskell'>=</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>v</span> <span class='token operator haskell'>!!</span> <span class='token identifier haskell'>i</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token operator haskell'>+</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>back</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token number haskell'>1</span> <span class='token operator haskell'>+</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>n</span> <span class='token operator haskell'>+</span> <span class='token number haskell'>1</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token operator haskell'>*</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>w</span> <span class='token operator haskell'>!!</span> <span class='token identifier haskell'>i</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token identifier haskell'>cs</span><span class='token delimiter parenthesis haskell bracket-close'>)</span></code></pre></div>
<p class="p indent" data-line="611"><span data-line="611"></span>4つの場合分けを行っています。
</p>
<p class="p indent" data-line="613"><span data-line="613"></span>まず(a)についてですが、これは終端の葉の時、つまり <span data-line="613"></span><code class="code code1" >(4,0)</code><span data-line="613"></span> が渡された時のものです。もちろんこれは0を返すことになります。
(b)についても同様に、<span data-line="614"></span><a href="#dp" class="localref" style="target-element:equation"><span class="equation-label">(15)</span></a><span data-line="614"></span> の定義通り i = n の時は 0 を返します。
</p>
<p class="p indent" data-line="616"><span data-line="616"></span>問題は(c),(d)の部分です。
<span data-line="617"></span><a href="#dp" class="localref" style="target-element:equation"><span class="equation-label">(15)</span></a><span data-line="617"></span> と比較することによって、<span data-line="617"></span><code class="code code1" >x1</code><span data-line="617"></span> が <span data-line="617"></span><span class="math-inline">$dp[i+1][j]$</span><span data-line="617"></span>、<span data-line="617"></span><code class="code code1" >x2</code><span data-line="617"></span> が <span data-line="617"></span><span class="math-inline">$dp[i+1][j-w[i]]+v[i]$</span><span data-line="617"></span> であることが推測できます。x1, x2 では <span data-line="617"></span><code class="code code1" >back</code><span data-line="617"></span> という関数を使っています。
</p>
<div class="framed" data-line="619" style="border:solid black 1px">
<pre class="para-block pre-fenced pre-fenced3 language-haskell lang-haskell haskell highlighted"  data-line="620" data-line-first="621" ><code data-line="621">  <span class='token comment haskell'>{-</span><span class='token comment haskell'> 過去の結果を遡って参照するための関数 </span><span class='token comment haskell'>-}</span><br>  <span class='token identifier haskell'>back</span> <span class='token number haskell'>1</span> <span class='token identifier haskell'>cs</span> <span class='token keyword operator haskell'>=</span> <span class='token identifier haskell'>extract</span> <span class='token identifier haskell'>cs</span><br>  <span class='token identifier haskell'>back</span> <span class='token identifier haskell'>i</span> <span class='token identifier haskell'>cs</span> <span class='token keyword operator haskell'>=</span> <span class='token keyword haskell'>case</span> <span class='token identifier haskell'>sub</span> <span class='token identifier haskell'>cs</span> <span class='token keyword haskell'>of</span><br>    <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>KSTree</span> <span class='token identifier wildcard haskell'>_</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token constructor haskell'>Just</span> <span class='token identifier haskell'>b</span><span class='token delimiter parenthesis haskell bracket-close'>)</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token keyword operator haskell'>-&gt;</span> <span class='token identifier haskell'>back</span> <span class='token delimiter parenthesis haskell bracket-open'>(</span><span class='token identifier haskell'>i</span><span class='token operator haskell'>-</span><span class='token number haskell'>1</span><span class='token delimiter parenthesis haskell bracket-close'>)</span> <span class='token identifier haskell'>b</span></code></pre></div>
<p class="p indent" data-line="628"><span data-line="628"></span>この <span data-line="628"></span><code class="code code1" >back</code><span data-line="628"></span> は 引数 i を与えると、現在時から i 時点前 (すなわち<span data-line="628"></span><span class="math-inline">${\tilde F}$</span><span data-line="628"></span>-treeにおけるi代目の子孫ノード) の結果を取得して返してきます。
つまり、リスト<span data-line="629"></span>&nbsp;<a href="#dozenlist" class="localref" style="target-element:pre">18</a><span data-line="629"></span> においては、現在 <span data-line="629"></span><code class="code code1" >cs</code><span data-line="629"></span> が <span data-line="629"></span><code class="code code1" >(i,j)</code><span data-line="629"></span> のノードであるとすると、<span data-line="629"></span><code class="code code1" >back 1 cs</code><span data-line="629"></span> は <span data-line="629"></span><code class="code code1" >(i-1,j)</code><span data-line="629"></span> の時点の結果を返し<span data-line="629"></span><sup id="back-fn-back1" ><a href="#fn-back1" title="15.直前の値なので extract で取得できます。直前の値の取得は別に ${\tilde F}$-tree でなくても catamorphism で可能です。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">15</span></a></sup><span data-line="629"></span>、<span data-line="629"></span><code class="code code1" >back (1 + (n + 1) * (w !! i)) cs</code><span data-line="629"></span> は <span data-line="629"></span><code class="code code1" >(i-1,j-w[i])</code><span data-line="629"></span> <span data-line="629"></span><sup id="back-fn-back2" ><a href="#fn-back2" title="16.$(n+1) \times c$の2次元配列をリストで表現しているので (i,j) から (i+N,j-M) を参照するためには N + M * (n + 1) 回遡る必要があります。
&#8617;" class="footnote-ref localref" ><span class="footnote-label">16</span></a></sup><span data-line="629"></span> 時点の結果を返すことになります。よって先ほどの推測は正しく、<span data-line="629"></span><a href="#dp" class="localref" style="target-element:equation"><span class="equation-label">(15)</span></a><span data-line="629"></span> を実装できたことが確認できました。
</p>
<p class="p indent" data-line="631"><span data-line="631"></span>一応畳み込む際の途中計算の結果を示しておきます。(実際には呼ばれない部分にも値が入っています)余裕があれば手で追ってみてください。
</p>
<pre class="para-block pre-fenced pre-fenced3"  data-line="633" data-line-first="634"><code data-line="634">13:(0,5) 13:(1,5) 13:(2,5) 8:(3,5) 0:(4,5)
13:(0,4) 13:(1,4) 13:(2,4) 8:(3,4) 0:(4,4)
 9:(0,3)  8:(1,3)  8:(2,3) 8:(3,3) 0:(4,3)
 5:(0,2)  5:(1,2)  5:(2,2) 0:(3,2) 0:(4,2)
 5:(0,1)  5:(1,1)  5:(2,1) 0:(3,1) 0:(4,1)
 0:(0,0)  0:(1,0)  0:(2,0) 0:(3,0) 0:(4,0)</code></pre><h2 id="matome" class="h1"    data-line="642"  style="display:block;bookmark:7.&#8194;\307E \3068 \3081 ;level:1"><span data-line="642"></span><span class="heading-before"><span class="heading-label">7</span>.&#8194;</span><span data-line="642"></span>まとめ</h2>
<ul class="ul list-star compact"  data-line="644">
<li class="li ul-li list-star-li compact-li"  data-line="644"><span data-line="644"></span>再帰的データ構造は<span data-line="644"></span><strong class="strong-star2" >関手</strong><span data-line="644"></span>の<span data-line="644"></span><strong class="strong-star2" >不動点</strong><span data-line="644"></span>で表せます。
</li>
<li class="li ul-li list-star-li compact-li"  data-line="645"><span data-line="645"></span><strong class="strong-star2" >F-代数</strong><span data-line="645"></span> とは、型と関数のペア <span data-line="645"></span><span class="math-inline">$(A, f : F(A) \to A)$</span><span data-line="645"></span> のことを言います。その双対である<span data-line="645"></span><strong class="strong-star2" >F-余代数</strong><span data-line="645"></span> は <span data-line="645"></span><span class="math-inline">$(B, g: B \to F(B))$</span><span data-line="645"></span> です。(余)代数間で構造を保つ写像を<span data-line="645"></span><strong class="strong-star2" >準同型</strong><span data-line="645"></span> といいます。
</li>
<li class="li ul-li list-star-li compact-li"  data-line="646"><span data-line="646"></span><strong class="strong-star2" >F-代数</strong><span data-line="646"></span>において <span data-line="646"></span><span class="math-inline">$(\mu F, {\sf inF})$</span><span data-line="646"></span> からの準同型 のことを <span data-line="646"></span><strong class="strong-star2" >catamorphism</strong><span data-line="646"></span>といいます。これはデータ構造の畳込みを行います。
</li>
<li class="li ul-li list-star-li compact-li"  data-line="647"><span data-line="647"></span><strong class="strong-star2" >F-余代数</strong><span data-line="647"></span>において <span data-line="647"></span><span class="math-inline">$(\mu F, outF)$</span><span data-line="647"></span> への準同型 のことを <span data-line="647"></span><strong class="strong-star2" >anamorphism</strong><span data-line="647"></span>といいます。これはデータ構造の構築を行います。
</li>
<li class="li ul-li list-star-li compact-li"  data-line="648"><span data-line="648"></span><strong class="strong-star2" >hylomorphism</strong><span data-line="648"></span> は anamorphism が出力したデータ構造を catamorphism に入力して得られる結果を返します。
</li>
<li class="li ul-li list-star-li compact-li"  data-line="649"><span data-line="649"></span><span class="math-inline">${\tilde F}(A)$</span><span data-line="649"></span> とは、<span data-line="649"></span><span class="math-inline">$\mu F$</span><span data-line="649"></span> のそれぞれのノードに 情報 <span data-line="649"></span><span class="math-inline">$A$</span><span data-line="649"></span> を付加したものです。
</li>
<li class="li ul-li list-star-li compact-li"  data-line="650"><span data-line="650"></span><strong class="strong-star2" >histmorphism</strong><span data-line="650"></span> は、関手 <span data-line="650"></span><span class="math-inline">$F$</span><span data-line="650"></span> に対して <span data-line="650"></span><span class="math-inline">${\tilde F}$</span><span data-line="650"></span> を考え、その上の catamorphism を行います。
</li>
<li class="li ul-li list-star-li compact-li"  data-line="651"><span data-line="651"></span><strong class="strong-star2" >dynamorphism</strong><span data-line="651"></span> は、anamorphism が出力したデータ構造を histmorphism に入力して得られる結果を返します。
</li></ul>
<h2 id="atogaki" class="h1"    data-line="653"  style="display:block;bookmark:8.&#8194;\3042 \3068 \304C \304D ;level:1"><span data-line="653"></span><span class="heading-before"><span class="heading-label">8</span>.&#8194;</span><span data-line="653"></span>あとがき</h2>
<p class="p indent" data-line="655"><span data-line="655"></span>今回は catamorphism, anamorphism, histmorphism, dynamorphism について説明しました。しかし<span data-line="655"></span> <span data-line="655"></span>-morphism は他にもあります。
histmorphism の双対である futumorphism、その2つを繋げた chronomorphism、hylomorphism での ana, cata の関数合成を逆にした metamorphism
また catamorphism を拡張した paramorphism, zygomorphism, prepromorphism、それらの双対である apomorphism, cozygomorphism, postproporphism、
他にも synchromorphism や exomorphism や mutumorphism などもあります。これらの morphism (まとめて <span data-line="658"></span><strong class="strong-star2" >recursion schemes</strong><span data-line="658"></span> と呼ばれます)は Haskell では<span data-line="658"></span>&nbsp;<a href="https://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a><span data-line="658"></span> などに実装されています。
</p>
<p class="p indent" data-line="660"><span data-line="660"></span>以上 dynamorphism とそれに至る経緯について長々と説明してきました。しかし説明が不十分であったり分かりにくい所も多いと思います。その際は、原論文 (参考文献<span data-line="660"></span>[1]<span data-line="660"></span>)を当たったり、実際に自分の手で実装したりしてみてください。
</p>
<p class="p indent" data-line="662"><span data-line="662"></span>また、今回の話は圏論について余り触れませんでした。圏論は抽象的で難しくて役に立つかわからないと思うかもしれませんが、主に関数型プログラミングなどの計算機科学の論文を当たると、圏論を用いて明快な結果を出しているものも多いです。最近圏論に関する本やネットの記事も増えてきているので、一度触れてみてはどうでしょうか。
</p><h2 id="bib" class="h1"    data-line="664"  style="display:block;bookmark:9.&#8194;\53C2 \8003 \6587 \732E ;level:1"><span data-line="664"></span><span class="heading-before"><span class="heading-label">9</span>.&#8194;</span><span data-line="664"></span>参考文献</h2>
<ol class="ol compact"  data-line="666">
<li class="li ol-li compact-li"  data-line="666">
<dl class="dl compact"  data-line="666">
<dt class="dt noindent dl-li compact-li"  style="text-indent:0em;font-weight:bold">Jevgeni Kabanov and Varmo Vene. 2006. Recursion schemes for dynamic programming. In Proceedings of the 8th international conference on Mathematics of Program Construction (MPC&#39;06), Tarmo Uustalu (Ed.). Springer-Verlag, Berlin, Heidelberg, 235-252.</dt>
<dd class="dd"  data-line="666" style="margin-left:1.5em"><span data-line="666"></span>dynamorpism の初出論文です。この記事とだいたい同じ流れ(cata, ana, histo から dynamorpism に至る)で構成されています。dynamorphismを利用した例として編集距離やLCSの例が挙げられています。</dd></dl></li>
<li class="li ol-li compact-li"  data-line="668">
<dl class="dl compact"  data-line="668">
<dt class="dt noindent dl-li compact-li"  style="text-indent:0em;font-weight:bold">Ralf Hinze and Nicolas Wu. 2013. Histo- and dynamorphisms revisited. In Proceedings of the 9th ACM SIGPLAN workshop on Generic programming (WGP &#39;13). ACM, New York, NY, USA, 1-12. </dt>
<dd class="dd"  data-line="668" style="margin-left:1.5em"><span data-line="668"></span>dynamorphism に触れている2つめの論文です。この論文では Comonad や λ-bicategory などを用いてより高度な議論をしています。サンプルコードとしてカタラン数や制限巡回セールスマン問題などを挙げています。</dd></dl></li>
<li class="li ol-li compact-li"  data-line="670"><span data-line="670"></span><a href="http://research.microsoft.com/en-us/um/people/daan/madoko/doc/reference.html">Madoko Reference</a><span data-line="670"></span>
: この文章は madoko を用いて生成されました。madoko は Markdown を学術論文向けに拡張し、PDF(LaTeX経由)やHTMLを出力します。開発者はMSRの人のようです。
</li>
<li class="li ol-li compact-li"  data-line="672"><span data-line="672"></span><a href="https://speakerdeck.com/amutake/dai-shu-de-detaxing-nituite-number-w8lt">代数的データ型について #w8lt // Speaker Deck</a><span data-line="672"></span>
: 代数的データ型がなぜ代数と呼ばれるかという疑問からF-代数に至るまでのスライドです。W8LTは東京工業大学という大学のの西8号館と呼ばれる建物で行われたライトニングトークを指すようです。
</li>
<li class="li ol-li compact-li"  data-line="674"><span data-line="674"></span><a href="https://gist.github.com/YoEight/9710441">Computes Fibonacci number with a histomorphism &#8211; correction: Actually it&#39;s a dynamorphism as it uses an anamorphism to generate intermediary step</a><span data-line="674"></span>
: 関数 <span data-line="675"></span><code class="code code1" >fibAsHisto</code><span data-line="675"></span> を作成する際に参考にしました。
</li>
<li class="li ol-li compact-li"  data-line="676"><span data-line="676"></span><a href="http://dai1741.github.io/maximum-algo-2012/docs/dynamic-programming/">動的計画法（ナップサック問題） - アルゴリズム講習会</a><span data-line="676"></span>
: DP の式などを参考にしました。
</li>
<li class="li ol-li compact-li"  data-line="678"><span data-line="678"></span><a href="http://akagi.ms.u-tokyo.ac.jp/input9.pdf">XY-pic</a><span data-line="678"></span>
: 可換図式を作成する際に参考にしました。
</li>
<li class="li ol-li compact-li"  data-line="680"><span data-line="680"></span><a href="https://ncatlab.org/nlab/show/HomePage">nLab</a><span data-line="680"></span>
: 圏論に関する百科事典です。
</li>
<li class="li ol-li compact-li"  data-line="682"><span data-line="682"></span><a href="http://nineties.github.io/category-seminar/10.html">圏論勉強会 第10回 @ ワークスアプリケーションズ</a><span data-line="682"></span>
: F-代数について分かりやすく説明しています。圏論勉強会の他のスライドもおすすめです。実は僕も2年前にこの勉強会に参加していました。
</li>
<li class="li ol-li compact-li"  data-line="684"><span data-line="684"></span><a href="http://titech-ssr.blog.jp/archives/1047298157.html">万物の創造 : 東京工業大学 ロボット技術研究会</a><span data-line="684"></span>
</li>
<li class="li ol-li compact-li"  data-line="685"><span data-line="685"></span><a href="http://comonad.com/reader/2009/recursion-schemes/">The Comonad.Reader &#187; Recursion Schemes: A Field Guide (Redux)</a><span data-line="685"></span>
</li></ol>
</div><span data-line=""></span>
<div class="footnotes madoko">
<hr >

<div id="fn-sirouto" class="footnote" data-line="687" style="line-adjust:0">
<p class="p indent" data-line="687"><span data-line="687"></span><span class="footnote-before"><sup ><span class="footnote-label">1</span>.</sup></span><span data-line="687"></span>ここでいう素人とは、その分野の研究者・専門家ではない、また専門教育を受けていないことを意味します。
<span data-line="688"></span><span data-line="688"></span><a href="#back-fn-sirouto" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-union" class="footnote" data-line="688" style="line-adjust:0">
<p class="p indent" data-line="688"><span data-line="688"></span><span class="footnote-before"><sup ><span class="footnote-label">2</span>.</sup></span><span data-line="688"></span>実際はAとBどちらの値を持つかの情報を持っている必要があります(<span data-line="688"></span><a href="https://en.wikipedia.org/wiki/Tagged_union">Tagged Union</a><span data-line="688"></span>)
<span data-line="689"></span><span data-line="689"></span><a href="#back-fn-union" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-func1" class="footnote" data-line="689" style="line-adjust:0">
<p class="p indent" data-line="689"><span data-line="689"></span><span class="footnote-before"><sup ><span class="footnote-label">3</span>.</sup></span><span data-line="689"></span>ここではHask圏の自己関手のことを「関手」と表記します。以下の文についても同様です。
<span data-line="690"></span><span data-line="690"></span><a href="#back-fn-func1" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-fixedf" class="footnote" data-line="690" style="line-adjust:0">
<p class="p indent" data-line="690"><span data-line="690"></span><span class="footnote-before"><sup ><span class="footnote-label">4</span>.</sup></span><span data-line="690"></span>つまり、<span data-line="690"></span><span class="math-inline">$\mu F$</span><span data-line="690"></span> について、<span data-line="690"></span><span class="math-inline">$f: \mu F \to F(\mu F)$</span><span data-line="690"></span> と <span data-line="690"></span><span class="math-inline">$g: F(\mu F) \to \mu F$</span><span data-line="690"></span> が一意に存在し、<span data-line="690"></span><span class="math-inline">$f \circ g = id_{F(\mu F)}, g \circ f = id_{\mu F}$</span><span data-line="690"></span>を満たすことを意味します。
<span data-line="691"></span><span data-line="691"></span><a href="#back-fn-fixedf" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-falg" class="footnote" data-line="691" style="line-adjust:0">
<p class="p indent" data-line="691"><span data-line="691"></span><span class="footnote-before"><sup ><span class="footnote-label">5</span>.</sup></span><span data-line="691"></span>要するに (F,f) を対象、準同型を射とする圏 <span data-line="691"></span><span class="math-inline">${\mathcal Alg}(F)$</span><span data-line="691"></span> の始対象がF-始代数。また、F-始代数は(存在すれば)同型を除いて一意。
<span data-line="692"></span><span data-line="692"></span><a href="#back-fn-falg" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-initialf" class="footnote" data-line="692" style="line-adjust:0">
<p class="p indent" data-line="692"><span data-line="692"></span><span class="footnote-before"><sup ><span class="footnote-label">6</span>.</sup></span><span data-line="692"></span>実は「<span data-line="692"></span><span class="math-inline">$(\mu F, {\sf inF})$</span><span data-line="692"></span> が始代数であるならば、<span data-line="692"></span><span class="math-inline">$\mu F$</span><span data-line="692"></span> は不動点である」という<span data-line="692"></span><a href="https://ncatlab.org/nlab/show/initial+algebra+of+an+endofunctor#LambeksTheorem">Lambekの定理</a><span data-line="692"></span>をもとに始対象から不動点である事実を導いているのですが、ここでは説明の流れが逆(不動点→始対象)になっています。
<span data-line="693"></span><span data-line="693"></span><a href="#back-fn-initialf" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-fcoalg" class="footnote" data-line="693" style="line-adjust:0">
<p class="p indent" data-line="693"><span data-line="693"></span><span class="footnote-before"><sup ><span class="footnote-label">7</span>.</sup></span><span data-line="693"></span>要するに (F,f) を対象、準同型を射とする圏 <span data-line="693"></span><span class="math-inline">${\mathcal CoAlg}(F)$</span><span data-line="693"></span> の終対象がF-終余代数。また、F-終余代数は(存在すれば)同型を除いて一意。
<span data-line="694"></span><span data-line="694"></span><a href="#back-fn-fcoalg" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-terminalf" class="footnote" data-line="694" style="line-adjust:0">
<p class="p indent" data-line="694"><span data-line="694"></span><span class="footnote-before"><sup ><span class="footnote-label">8</span>.</sup></span><span data-line="694"></span>この時、正確には終余代数となるのは最<span data-line="694"></span><em class="em-star1" >大</em><span data-line="694"></span>不動点 <span data-line="694"></span><span class="math-inline">$\nu F$</span><span data-line="694"></span> ですが、言及している状況下では、最大不動点と最小不動点は一致するので<span data-line="694"></span><span class="math-inline">$\mu F$</span><span data-line="694"></span>としています。
<span data-line="695"></span><span data-line="695"></span><a href="#back-fn-terminalf" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-cata" class="footnote" data-line="695" style="line-adjust:0">
<p class="p indent" data-line="695"><span data-line="695"></span><span class="footnote-before"><sup ><span class="footnote-label">9</span>.</sup></span><span data-line="695"></span>日本語訳は知るかぎりではありません。無理やり訳すなら「下射」みたいな？
<span data-line="696"></span><span data-line="696"></span><a href="#back-fn-cata" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-ana" class="footnote" data-line="696" style="line-adjust:0">
<p class="p indent" data-line="696"><span data-line="696"></span><span class="footnote-before"><sup ><span class="footnote-label">10</span>.</sup></span><span data-line="696"></span>無理やり訳すなら「上射」です。
<span data-line="697"></span><span data-line="697"></span><a href="#back-fn-ana" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-hylo" class="footnote" data-line="697" style="line-adjust:0">
<p class="p indent" data-line="697"><span data-line="697"></span><span class="footnote-before"><sup ><span class="footnote-label">11</span>.</sup></span><span data-line="697"></span>hylo- には「物」などの意味があるようです。余談なのですが、アリストテレス哲学の文脈でも hylomorphism というものがあり、これは質料形相論と訳されます。ここでは全く関係ありません。
<span data-line="698"></span><span data-line="698"></span><a href="#back-fn-hylo" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-cofree" class="footnote" data-line="698" style="line-adjust:0">
<p class="p indent" data-line="698"><span data-line="698"></span><span class="footnote-before"><sup ><span class="footnote-label">12</span>.</sup></span><span data-line="698"></span>Cofree という名前は、Cofree Comonad から来ています。実際この<span data-line="698"></span><span class="math-inline">${\tilde F}(X)$</span><span data-line="698"></span>はComonadになります。圏<span data-line="698"></span><span class="math-inline">${\mathcal CoAlg}(F)$</span><span data-line="698"></span>から<span data-line="698"></span><span class="math-inline">$Hask$</span><span data-line="698"></span>への忘却関手 <span data-line="698"></span><span class="math-inline">$U_F (A, a) = A$</span><span data-line="698"></span> は、<span data-line="698"></span><span class="math-inline">${\sf Cofree}_F A = (\tilde F(A), \theta)$</span><span data-line="698"></span> という右随伴を持ち、それらの随伴対から comonad <span data-line="698"></span><span class="math-inline">${\tilde F} = {\sf U}_F \circ {\sf Cofree}_F$</span><span data-line="698"></span> が導かれます。
<span data-line="699"></span><span data-line="699"></span><a href="#back-fn-cofree" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-histo2" class="footnote" data-line="699" style="line-adjust:0">
<p class="p indent" data-line="699"><span data-line="699"></span><span class="footnote-before"><sup ><span class="footnote-label">13</span>.</sup></span><span data-line="699"></span>原論文(参考文献<span data-line="699"></span>[1]<span data-line="699"></span>)によればこの定義のほうが <span data-line="699"></span><em class="em-star1" >more efficient</em><span data-line="699"></span> らしいです。
<span data-line="700"></span><span data-line="700"></span><a href="#back-fn-histo2" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-dyna" class="footnote" data-line="700" style="line-adjust:0">
<p class="p indent" data-line="700"><span data-line="700"></span><span class="footnote-before"><sup ><span class="footnote-label">14</span>.</sup></span><span data-line="700"></span>原論文(参考文献<span data-line="700"></span>[1]<span data-line="700"></span>)では <span data-line="700"></span><span class="math-inline">$\varphi \circ F({\sf ana} \langle f, \psi \rangle) \circ \psi = f$</span><span data-line="700"></span> となるような <span data-line="700"></span><span class="math-inline">$f$</span><span data-line="700"></span> を dynamorphism と定義し、そこから非自明に<span data-line="700"></span>&nbsp;<a href="#dynadef" class="localref" style="target-element:equation"><span class="equation-label">(13)</span></a><span data-line="700"></span> を導いているのですが、都合上(訳:証明がわからない)のでこれを定義にしています。
<span data-line="701"></span><span data-line="701"></span><a href="#back-fn-dyna" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-back1" class="footnote" data-line="701" style="line-adjust:0">
<p class="p indent" data-line="701"><span data-line="701"></span><span class="footnote-before"><sup ><span class="footnote-label">15</span>.</sup></span><span data-line="701"></span>直前の値なので <span data-line="701"></span><code class="code code1" >extract</code><span data-line="701"></span> で取得できます。直前の値の取得は別に <span data-line="701"></span><span class="math-inline">${\tilde F}$</span><span data-line="701"></span>-tree でなくても catamorphism で可能です。
<span data-line="702"></span><span data-line="702"></span><a href="#back-fn-back1" class="footnote-backref localref">&#8617;</a></p></div>
<div id="fn-back2" class="footnote" data-line="702" style="line-adjust:0">
<p class="p indent" data-line="702"><span data-line="702"></span><span class="footnote-before"><sup ><span class="footnote-label">16</span>.</sup></span><span data-line="702"></span><span class="math-inline">$(n+1) \times c$</span><span data-line="702"></span>の2次元配列をリストで表現しているので <span data-line="702"></span><code class="code code1" >(i,j)</code><span data-line="702"></span> から <span data-line="702"></span><code class="code code1" >(i+N,j-M)</code><span data-line="702"></span> を参照するためには <span data-line="702"></span><code class="code code1" >N + M * (n + 1)</code><span data-line="702"></span> 回遡る必要があります。
<span data-line="703"></span><span data-line="703"></span><a href="#back-fn-back2" class="footnote-backref localref">&#8617;</a></p></div></div>
</body>

</html>
